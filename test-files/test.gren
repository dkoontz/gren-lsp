## Testing with dump of several gren-lang/core files.

effect module Random where { command = MyCmd } exposing
  ( Generator, Seed
  , int, float, uniform, weighted, constant
  , array, pair
  , map, map2, map3, andMap
  , andThen, lazy
  , minInt, maxInt
  , generate
  , step, initialSeed, independentSeed
  )

{-| This API helps you generate pseudo-random values.

It is an implementation of [Permuted Congruential Generators][pcg]
by M. E. O'Neil. It is not cryptographically secure.

[pcg]: http://www.pcg-random.org/


@docs Generator, generate

## Primitives
@docs int, float, uniform, weighted, constant

## Data Structures
@docs pair, array

## Mapping
@docs map, map2, map3, andMap

## Fancy Stuff
@docs andThen, lazy

## Constants
@docs maxInt, minInt

## Generate Values Manually
@docs Seed, step, initialSeed, independentSeed

-}

import Array exposing (Array)
import Basics exposing (..)
import Math exposing (abs, remainderBy)
import Maybe exposing (Maybe(..))
import Bitwise
import Platform
import Platform.Cmd exposing (Cmd)
import Task exposing (Task)
import Time



-- PRIMITIVE GENERATORS


{-| Generate 32-bit integers in a given range.

    import Random

    singleDigit : Random.Generator Int
    singleDigit =
        Random.int 0 9

    closeToZero : Random.Generator Int
    closeToZero =
        Random.int -5 5

    anyInt : Random.Generator Int
    anyInt =
        Random.int Random.minInt Random.maxInt

This generator *can* produce values outside of the range [[`minInt`](#minInt),
[`maxInt`](#maxInt)] but sufficient randomness is not guaranteed.
-}
int : Int -> Int -> Generator Int
int a b =
    Generator
        (\seed0 ->
            let
                { lo, hi } =
                    if a < b then
                        { lo = a, hi = b }
                    else
                        { lo = b, hi = a }

                range =
                    hi - lo + 1
            in
                -- fast path for power of 2
                if (Bitwise.and (range - 1) range) == 0 then
                    { value = (Bitwise.shiftRightZfBy 0 (Bitwise.and (range - 1) (peel seed0))) + lo, seed = next seed0 }
                else
                    let
                        threshhold =
                            -- essentially: period % max
                            Bitwise.shiftRightZfBy 0 (remainderBy range (Bitwise.shiftRightZfBy 0 -range))

                        accountForBias : Seed -> { value : Int, seed : Seed }
                        accountForBias seed =
                            let
                                x =
                                    peel seed

                                seedN =
                                    next seed
                            in
                                if x < threshhold then
                                    -- in practice this recurses almost never
                                    accountForBias seedN
                                else
                                    { value = remainderBy range x + lo, seed = seedN }
                    in
                        accountForBias seed0
        )


{-| The underlying algorithm works well in a specific range of integers.
It can generate values outside of that range, but they are “not as random”.

The `maxInt` that works well is `2147483647`.
-}
maxInt : Int
maxInt =
  2147483647


{-| The underlying algorithm works well in a specific range of integers.
It can generate values outside of that range, but they are “not as random”.

The `minInt` that works well is `-2147483648`.
-}
minInt : Int
minInt =
  -2147483648


{-| Generate floats in a given range.

    import Random

    probability : Random.Generator Float
    probability =
        Random.float 0 1

The `probability` generator will produce values between zero and one with
a uniform distribution. Say it produces a value `p`. We can then check if
`p < 0.4` if we want something to happen 40% of the time.

This becomes very powerful when paired with functions like [`map`](#map) and
[`andThen`](#andThen). Rather than dealing with twenty random float messages
in your `update`, you can build up sophisticated logic in the `Generator`
itself!
-}
float : Float -> Float -> Generator Float
float a b =
    Generator (\seed0 ->
        let
            -- Get 64 bits of randomness
            seed1 =
                next seed0

            n0 =
                peel seed0

            n1 =
                peel seed1

            { nHi, nLo } =
                if n0 > n1 then
                    { nHi = n0, nLo = n1 }

                else
                    { nHi = n1, nLo = n0 }

            -- Get a uniformly distributed IEEE-754 double between 0.0 and 1.0
            hi =
                toFloat (Bitwise.and 0x03FFFFFF nHi) * 1.0

            lo =
                toFloat (Bitwise.and 0x07FFFFFF nLo) * 1.0

            val =
                -- These magic constants are 2^27 and 2^53
                ((hi * 134217728.0) + lo) / 9007199254740992.0

            -- Scale it into our range
            range =
                abs (b - a)

            scaled =
                val * range + a
        in
            { value = scaled, seed = next seed1 }
        )


{-| Generate the same value every time.

    import Random

    alwaysFour : Random.Generator Int
    alwaysFour =
        Random.constant 4

Think of it as picking from a hat with only one thing in it. It is weird,
but it can be useful with [`elm-community/random-extra`][extra] which has
tons of nice helpers.

[extra]: /packages/elm-community/random-extra/latest
-}
constant : a -> Generator a
constant value =
  Generator (\seed -> { value = value, seed = seed })



-- DATA STRUCTURES


{-| Generate a pair of random values. A common use of this might be to generate
a point in a certain 2D space:

    import Random

    randomPoint : Random.Generator { first : Float, second : Float }
    randomPoint =
        Random.pair (Random.float -200 200) (Random.float -100 100)

Maybe you are doing an animation with SVG and want to randomly generate some
entities?
-}
pair : Generator a -> Generator b -> Generator { first : a, second : b }
pair genA genB =
  map2 (\a b -> { first = a, second = b }) genA genB


{-| Generate an array of random values.

    import Random

    tenFractions : Random.Generator (Array Float)
    tenFractions =
        Random.array 10 (Random.float 0 1)

    fiveGrades : Random.Generator (Array Int)
    fiveGrades =
        Random.array 5 (int 0 100)

If you want to generate an array with a random length, you need to use
[`andThen`](#andThen) like this:

    fiveToTenDigits : Random.Generator (Array Int)
    fiveToTenDigits =
        Random.int 5 10
          |> Random.andThen (\len -> Random.array len (Random.int 0 9))

This generator gets a random integer between five and ten **and then**
uses that to generate a random array of digits.
-}
array : Int -> Generator a -> Generator (Array a)
array n (Generator gen) =
  Generator (\seed ->
    arrayHelp [] n gen seed
  )


arrayHelp : Array a -> Int -> (Seed -> { value : a, seed : Seed }) -> Seed -> { value : Array a, seed : Seed }
arrayHelp revArray n gen seed =
  if n < 1 then
    { value = revArray, seed = seed}

  else
    let
      { value = value, seed = newSeed }  =
        gen seed
    in
      arrayHelp (Array.pushFirst value revArray) (n-1) gen newSeed



-- ENUMERATIONS


{-| Generate values with equal probability. Say we want a random suit for some
cards:

    import Random

    type Suit = Diamond | Club | Heart | Spade

    suit : Random.Generator Suit
    suit =
      Random.uniform Diamond [ Club, Heart, Spade ]

That generator produces all `Suit` values with equal probability, 25% each.

**Note:** Why not have `uniform : Array a -> Generator a` as the API? It looks
a little prettier in code, but it leads to an awkward question. What do you do
with `uniform []`? How can it produce an `Int` or `Float`? The current API
guarantees that we always have *at least* one value, so we never run into that
question!
-}
uniform : a -> Array a -> Generator a
uniform value valueArray =
  weighted (addOne value) (Array.map addOne valueArray)


addOne : a -> { weight : Float, value : a }
addOne value =
  { weight = 1, value = value }


{-| Generate values with a _weighted_ probability. Say we want to simulate a
[loaded die](https://en.wikipedia.org/wiki/Dice#Loaded_dice) that lands
on ⚄ and ⚅ more often than the other faces:

    import Random

    type Face = One | Two | Three | Four | Five | Six

    roll : Random.Generator Face
    roll =
      Random.weighted
        { weight : 10, value : One }
        [ { weight : 10, value : Two }
        , { weight : 10, value : Three }
        , { weight : 10, value : Four }
        , { weight : 20, value : Five }
        , { weight : 40, value : Six }
        ]

So there is a 40% chance of getting `Six`, a 20% chance of getting `Five`, and
then a 10% chance for each of the remaining faces.

**Note:** I made the weights add up to 100, but that is not necessary. I always
add up your weights into a `total`, and from there, the probablity of each case
is `weight / total`. Negative weights do not really make sense, so I just flip
them to be positive.
-}
weighted : { weight : Float, value : a } -> Array { weight : Float, value : a } -> Generator a
weighted first others =
  let
    normalize { weight = weight } =
      abs weight

    total =
      normalize first + (Array.foldl (\weight sum -> sum + normalize weight) 0 others)
  in
  map (getByWeight first others) (float 0 total)


getByWeight : { weight : Float, value : a } -> Array { weight : Float, value : a } -> Float -> a
getByWeight {weight = weight, value = value} others countdown =
  when Array.popFirst others is
    Nothing ->
      value

    Just { first = second, rest = otherOthers } ->
      if countdown <= abs weight then
        value
      else
        getByWeight second otherOthers (countdown - abs weight)



-- CUSTOM GENERATORS


{-| Transform the values produced by a generator. For example, we can
generate random boolean values:

    import Random

    bool : Random.Generator Bool
    bool =
      Random.map (\n -> n < 20) (Random.int 1 100)

The `bool` generator first picks a number between 1 and 100. From there
it checks if the number is less than twenty. So the resulting `Bool` will
be `True` about 20% of the time.

You could also do this for lower case ASCII letters:

    letter : Random.Generator Char
    letter =
      Random.map (\n -> Char.fromCode (n + 97)) (Random.int 0 25)

The `letter` generator first picks a number between 0 and 25 inclusive.
It then uses `Char.fromCode` to turn [ASCII codes][ascii] into `Char` values.

**Note:** Instead of making these yourself, always check if the
[`random-extra`][extra] package has what you need!

[ascii]: https://en.wikipedia.org/wiki/ASCII#Printable_characters
[extra]: /packages/elm-community/random-extra/latest
-}
map : (a -> b) -> Generator a -> Generator b
map func (Generator genA) =
  Generator (\seed0 ->
    let
      { value = a, seed = seed1 } = genA seed0
    in
      { value = func a, seed = seed1 }
  )


{-| Combine two generators. Maybe we have a space invaders game and want to
generate enemy ships with a random location:

    import Random

    type alias Enemy =
      { health : Float
      , rotation : Float
      , x : Float
      , y : Float
      }

    enemy : Random.Generator Enemy
    enemy =
      Random.map2
        (\x y ->
          { health = 100
          , rotation = 0
          , x = x
          , y = y
          }
        )
        (Random.float 0 100)
        (Random.float 0 100)

Now whenever we run the `enemy` generator we get an enemy with full health,
no rotation, and a random position! Now say we want to start with between
five and ten enemies on screen:

    initialEnemies : Random.Generator (Array Enemy)
    initialEnemies =
      Random.int 5 10
        |> Random.andThen (\num -> Random.array num enemy)

We will generate a number between five and ten, **and then** generate
that number of enemies!

**Note:** Snapping generators together like this is very important! Always
start by with generators for each `type` you need, and then snap them
together.
-}
map2 : (a -> b -> c) -> Generator a -> Generator b -> Generator c
map2 func (Generator genA) (Generator genB) =
  Generator (\seed0 ->
    let
      { value = a, seed = seed1 } = genA seed0
      { value = b, seed = seed2 } = genB seed1
    in
      { value = func a b, seed = seed2 }
  )


{-| Combine three generators. Maybe you want to make a simple slot machine?

    import Random

    type alias Spin =
      { one : Symbol
      , two : Symbol
      , three : Symbol
      }

    type Symbol = Cherry | Seven | Bar | Grapes

    spin : Random.Generator Spin
    spin =
      Random.map3 (\one two three -> { one = one, two = two, three = three })
        symbol
        symbol
        symbol

    symbol : Random.Generator Symbol
    symbol =
      Random.uniform Cherry [ Seven, Bar, Grapes ]

**Note:** Always start with the types. Make a generator for each thing you need
and then put them all together with one of these `map` functions.
-}
map3 : (a -> b -> c -> d) -> Generator a -> Generator b -> Generator c -> Generator d
map3 func (Generator genA) (Generator genB) (Generator genC) =
  Generator (\seed0 ->
    let
      { value = a, seed = seed1 } = genA seed0
      { value = b, seed = seed2 } = genB seed1
      { value = c, seed = seed3 } = genC seed2
    in
      { value = func a b c, seed = seed3 }
  )


{-| Combine any number of generators.

Say you are making game and want to place enemies or terrain randomly. You
_could_ generate a [quadtree](https://en.wikipedia.org/wiki/Quadtree)!

    import Random

    type QuadTree a
      = Empty
      | Leaf a
      | Node { one : QuadTree a, two : QuadTree a, three : QuadTree a, four : QuadTree a }

    quadTree : Random.Generator a -> Random.Generator (QuadTree a)
    quadTree leafGen =
      let
        subQuads =
          Random.lazy (\_ -> quadTree leafGen)
      in
      Random.andThen identity <|
        Random.uniform
          (Random.constant Empty)
          [ Random.map Leaf leafGen
          , Random.constant (\one two three four -> Node { one = one, two = two, three = three, four = four})
              |> Random.andMap subQuad
              |> Random.andMap subQuad
              |> Random.andMap subQuad
              |> Random.andMap subQuad
          ]

We start by creating a `QuadTree` type where each quadrant is either `Empty`, a
Leaf` containing something interesting, or a `Node` with four sub-quadrants.

Next the `quadTree` definition describes how to generate these values. A third
of a time you get an `Empty` tree. A third of the time you get a `Leaf` with
some interesting value. And a third of the time you get a `Node` full of more
QuadTree` values. How are those subtrees generated though? Well, we use our
quadTree` generator!
-}
andMap : Generator a -> Generator (a -> b) -> Generator b
andMap =
  map2 (|>)


{-| Generate fancy random values.

We have seen examples of how `andThen` can be used to generate variable length
arrays in the [`array`](#array) and [`map2`](#map2) docs. We saw how it could help
generate a quadtree in the [`map4`](#map4) docs.

Anything you could ever want can be defined using this operator! As one last
example, here is how you can define `map` using `andThen`:

    import Random

    map : (a -> b) -> Random.Generator a -> Random.Generator b
    map func generator =
      generator
        |> Random.andThen (\value -> Random.constant (func value))

The `andThen` function gets used a lot in [`elm-community/random-extra`][extra],
so it may be helpful to look through the implementation there for more examples.

[extra]: /packages/elm-community/random-extra/latest
-}
andThen : (a -> Generator b) -> Generator a -> Generator b
andThen callback (Generator genA) =
  Generator (\seed ->
    let
      { value = result, seed = newSeed } = genA seed
      (Generator genB) = callback result
    in
      genB newSeed
  )


{-| Helper for defining self-recursive generators. Say we want to generate a
random number of probabilities:

    import Random

    probabilities : Random.Generator (Array Float)
    probabilities =
      Random.andThen identity <|
        Random.uniform
          (Random.constant [])
          [ Random.map2 (::)
              (Random.float 0 1)
              (Random.lazy (\_ -> probabilities))
          ]

In 50% of cases we end the array. In 50% of cases we generate a probability and
add it onto a random number of probabilities. The `lazy` call is crucial
because it means we do not unroll the generator unless we need to.

This is a pretty subtle issue, so I recommend reading more about it
[here](https://elm-lang.org/0.19.0/bad-recursion)!

**Note:** You can delay evaluation with `andThen` too. The thing that matters
is that you have a function call that delays the creation of the generator!
-}
lazy : ({} -> Generator a) -> Generator a
lazy callback =
  Generator (\seed ->
    let
      (Generator gen) = callback {}
    in
      gen seed
  )


-- IMPLEMENTATION

{- Explanation of the PCG algorithm

    This is a special variation (dubbed RXS-M-SH) that produces 32
    bits of output by keeping 32 bits of state. There is one function
    (next) to derive the following state and another (peel) to obtain 32
    psuedo-random bits from the current state.

    Getting the next state is easy: multiply by a magic factor, modulus by 2^32,
    and then add an increment. If two seeds have different increments,
    their random numbers from the two seeds will never match up; they are
    completely independent. This is very helpful for isolated components or
    multithreading, and elm-test relies on this feature.

    Transforming a seed into 32 random bits is more complicated, but
    essentially you use the "most random" bits to pick some way of scrambling
    the remaining bits. Beyond that, see section 6.3.4 of the [paper].

    [paper](http://www.pcg-random.org/paper.html)

    Once we have 32 random bits, we have to turn it into a number. For integers,
    we first check if the range is a power of two. If it is, we can mask part of
    the value and be done. If not, we need to account for bias.

    Let's say you want a random number between 1 and 7 but I can only generate
    random numbers between 1 and 32. If I modulus by result by 7, I'm biased,
    because there are more random numbers that lead to 1 than 7. So instead, I
    check to see if my random number exceeds 28 (the largest multiple of 7 less
    than 32). If it does, I reroll, otherwise I mod by seven. This sounds
    wasteful, except that instead of 32 it's 2^32, so in practice it's hard to
    notice. So that's how we get random ints. There's another process from
    floats, but I don't understand it very well.
-}


{-| Maybe you do not want to use [`generate`](#generate) for some reason? Maybe
you need to be able to exactly reproduce a sequence of random values?

In that case, you can work with a `Seed` of randomness and [`step`](#step) it
forward by hand.
-}
type Seed
    = Seed { state : Int, increment : Int }
    -- state of the RNG and stepped with each random generation
    -- increment corresponds to an independent RNG


-- step the RNG to produce the next seed
-- this is incredibly simple: multiply the state by a constant factor, modulus it
-- by 2^32, and add a magic addend. The addend can be varied to produce independent
-- RNGs, so it is stored as part of the seed. It is given to the new seed unchanged.
next : Seed -> Seed
next (Seed { state = state0, increment = incr }) =
    -- The magic constant is from Numerical Recipes and is inlined for perf.
    Seed { state = (Bitwise.shiftRightZfBy 0 ((state0 * 1664525) + incr)), increment = incr }


-- obtain a psuedorandom 32-bit integer from a seed
peel : Seed -> Int
peel (Seed { state }) =
    -- This is the RXS-M-SH version of PCG, see section 6.3.4 of the paper
    -- and line 184 of pcg_variants.h in the 0.94 (non-minimal) C implementation,
    -- the latter of which is the source of the magic constant.
    let
        word =
            (Bitwise.xor state (Bitwise.shiftRightZfBy ((Bitwise.shiftRightZfBy 28 state) + 4) state)) * 277803737
    in
        Bitwise.shiftRightZfBy 0 (Bitwise.xor (Bitwise.shiftRightZfBy 22 word) word)


{-| A `Generator` is a **recipe** for generating random values. For example,
here is a generator for numbers between 1 and 10 inclusive:

    import Random

    oneToTen : Random.Generator Int
    oneToTen =
      Random.int 1 10

Notice that we are not actually generating any numbers yet! We are describing
what kind of values we want. To actually get random values, you create a
command with the [`generate`](#generate) function:

    type Msg = NewNumber Int

    newNumber : Cmd Msg
    newNumber =
      Random.generate NewNumber oneToTen

Each time you run this command, it runs the `oneToTen` generator and produces
random integers between one and ten.

**Note 1:** The random `Generator` API is quite similar to the JSON `Decoder` API, which we've inherited from Elm.
Both are building blocks that snap together with `map`, `map2`, etc. You can read
more about JSON decoders [here][json] to see the similarity.

[json]: https://guide.elm-lang.org/interop/json.html
-}
type Generator a =
    Generator (Seed -> { value : a, seed : Seed })


{-| So you need _reproducible_ randomness for some reason.

This `step` function lets you use a `Generator` without commands. It is a
normal Gren function. Same input, same output! So to get a 3D point you could
say:

    import Random

    type alias Point3D = { x : Float, y : Float, z : Float }

    makePoint3D : Float -> Float -> Float -> Point3D
    makePoint3D x y z =
      { x = x, y = y, z = z }

    point3D : Random.Seed -> { value : Point3D, seed : Random.Seed }
    point3D seed0 =
      let
        { value = x, seed = seed1 } = Random.step (Random.float 0 100) seed0
        { value = y, seed = seed2 } = Random.step (Random.float 0 100) seed1
        { value = z, seed = seed3 } = Random.step (Random.float 0 100) seed2
      in
        { value = makePoint3D x y z, seed = seed3 }

Notice that we use different seeds on each line! If we instead used `seed0`
for everything, the `x`, `y`, and `z` values would always be exactly the same!
Same input, same output!

Threading seeds around is not super fun, so if you really need this, it is
best to build your `Generator` like normal and then just `step` it all at
once at the top of your program.
-}
step : Generator a -> Seed -> { value : a, seed : Seed }
step (Generator generator) seed =
  generator seed


{-| Create a `Seed` for _reproducible_ randomness.

    import Random

    seed0 : Random.Seed
    seed0 =
      Random.initialSeed 42

If you hard-code your `Seed` like this, every run will be the same. This can
be useful if you are testing a game with randomness and want it to be easy to
reproduce past games.

In practice, you may want to get the initial seed by (1) sending it to Gren
through flags or (2) using `Time.now` to get a number that the user has not
seen before. (Flags are described on [this page][flags].)

[flags]: https://guide.elm-lang.org/interop/flags.html
-}
initialSeed : Int -> Seed
initialSeed x =
    let
        -- the default increment magic constant is taken from Numerical Recipes
        (Seed { state = state1, increment = incr }) =
            next (Seed { state = 0, increment = 1013904223 })

        state2 =
            Bitwise.shiftRightZfBy 0 (state1 + x)
    in
        next (Seed { state = state2, increment = incr })


{-| A generator that produces a seed that is independent of any other seed in
the program. These seeds will generate their own unique sequences of random
values. They are useful when you need an unknown amount of randomness *later*
but can request only a fixed amount of randomness *now*.

The independent seeds are extremely likely to be distinct for all practical
purposes. However, it is not proven that there are no pathological cases.
-}
independentSeed : Generator Seed
independentSeed =
    Generator <|
        \seed0 ->
            let
                gen =
                    int 0 0xFFFFFFFF

                {--
                Although it probably doesn't hold water theoretically, xor two
                random numbers to make an increment less likely to be
                pathological. Then make sure that it's odd, which is required.
                Next make sure it is positive. Finally step it once before use.
                --}
                makeIndependentSeed state b c =
                    next <| Seed { state = state, increment = Bitwise.shiftRightZfBy 0 (Bitwise.or 1 (Bitwise.xor b c)) }
            in
            step (map3 makeIndependentSeed gen gen gen) seed0



-- MANAGER


{-| Create a command that produces random values. Say you want to generate
random points:

    import Random

    point : Random.Generator { first : Int, second : Int }
    point =
      Random.pair (Random.int -100 100) (Random.int -100 100)

    type Msg = NewPoint { first : Int, second : Int }

    newPoint : Cmd Msg
    newPoint =
      Random.generate NewPoint point

Each time you run the `newPoint` command, it will produce a new 2D point like
`{ first = 57, second = 18 }` or `{ first = -82, second = 6 }`.

**Note:** Read through [guide.elm-lang.org][guide] to learn how commands work.
If you are coming from JS it can be hopelessly frustrating if you just try to
wing it. And definitely ask around on Slack if you feel stuck! Investing in
understanding generators is really worth it, and once it clicks, folks often
dread going back to `Math.random()` in JavaScript.

[guide]: https://guide.elm-lang.org/
-}
generate : (a -> msg) -> Generator a -> Cmd msg
generate tagger generator =
  command (Generate (map tagger generator))


type MyCmd msg = Generate (Generator msg)


cmdMap : (a -> b) -> MyCmd a -> MyCmd b
cmdMap func (Generate generator) =
  Generate (map func generator)


init : Task Never Seed
init =
  Task.andThen (\time -> Task.succeed (initialSeed (Time.posixToMillis time))) Time.now


onEffects : Platform.Router msg Never -> Array (MyCmd msg) -> Seed -> Task Never Seed
onEffects router commands seed =
  when Array.popFirst commands is
    Nothing ->
      Task.succeed seed

    Just { first = Generate generator, rest = rest } ->
      let
        { value = value, seed = newSeed } =
          step generator seed
      in
          Task.andThen
            (\_ -> onEffects router rest newSeed)
            (Platform.sendToApp router value)


onSelfMsg : Platform.Router msg Never -> Never -> Seed -> Task Never Seed
onSelfMsg _ _ seed =
  Task.succeed seed

## From Basics.gren
{-| Tons of useful functions that get imported by default.


## Numbers

@docs Int, (+), (-), (*), (/), (//), (^), negate


## Float

@docs Float, toFloat, isNaN, isInfinite


## Equality

@docs (==), (/=)


## Comparison

These functions only work on `comparable` types. This includes numbers,
characters, strings and arrays of comparable things.

@docs Order, (<), (>), (<=), (>=), max, min, clamp, compare


## Booleans

@docs Bool, not, (&&), (||), xor


## Append Strings and Arrays

@docs (++)


## Function Helpers

@docs identity, (<|), (|>), (<<), (>>), Never, never

-}

import Gren.Kernel.Basics
import Gren.Kernel.Utils



-- INFIX OPERATORS


infix right 0 (<|) = apL
infix left  0 (|>) = apR
infix right 2 (||) = or
infix right 3 (&&) = and
infix non   4 (==) = eq
infix non   4 (/=) = neq
infix non   4 (<) = lt
infix non   4 (>) = gt
infix non   4 (<=) = le
infix non   4 (>=) = ge
infix right 5 (++) = append
infix left  6 (+) = add
infix left  6 (-) = sub
infix left  7 (*) = mul
infix left  7 (/) = fdiv
infix left  7 (//) = idiv
infix right 8 (^) = pow
infix left  9 (<<) = composeL
infix right 9 (>>) = composeR



-- MATHEMATICS


{-| An `Int` is a whole number. Valid syntax for integers includes:

    0

    42

    9000

    0xFF -- 255 in hexadecimal

    0x0A --  10 in hexadecimal

**Note:** `Int` math is well-defined in the range `-2^31` to `2^31 - 1`. Outside
of that range, the behavior is determined by the compilation target. When
generating JavaScript, the safe range expands to `-(2^53 - 1)` to `2^53 - 1` for some
operations, but if we generate WebAssembly some day, we would do the traditional
[integer overflow][io]. This quirk is necessary to get good performance on
quirky compilation targets.

**Historical Note:** The name `Int` comes from the term [integer]. It appears
that the `int` abbreviation was introduced in [ALGOL 68][68], shortening it
from `integer` in [ALGOL 60][60]. Today, almost all programming languages use
this abbreviation.

[io]: https://en.wikipedia.org/wiki/Integer_overflow
[integer]: https://en.wikipedia.org/wiki/Integer
[60]: https://en.wikipedia.org/wiki/ALGOL_60
[68]: https://en.wikipedia.org/wiki/ALGOL_68

-}
type Int
    = Int -- NOTE: The compiler provides the real implementation.


{-| A `Float` is a [floating-point number][fp]. Valid syntax for floats includes:

    0
    42
    3.14
    0.1234
    6.022e23   -- == (6.022 * 10^23)
    6.022e+23  -- == (6.022 * 10^23)
    1.602e−19  -- == (1.602 * 10^-19)
    1e3        -- == (1 * 10^3) == 1000

**Historical Note:** The particular details of floats (e.g. `NaN`) are
specified by [IEEE 754][ieee] which is literally hard-coded into almost all
CPUs in the world. That means if you think `NaN` is weird, you must
successfully overtake Intel and AMD with a chip that is not backwards
compatible with any widely-used assembly language.

[fp]: https://en.wikipedia.org/wiki/Floating-point_arithmetic
[ieee]: https://en.wikipedia.org/wiki/IEEE_754

-}
type Float
    = Float -- NOTE: The compiler provides the real implementation.


{-| Add two numbers. The `number` type variable means this operation can be
specialized to `Int -> Int -> Int` or to `Float -> Float -> Float`. So you
can do things like this:

    3002 + 4004 == 7006 -- all ints

    3.14 + 3.14 == 6.28 -- all floats

You _cannot_ add an `Int` and a `Float` directly though. Use functions like
[toFloat](#toFloat) or [round](#round) to convert both values to the same type.
So if you needed to add a array length to a `Float` for some reason, you
could say one of these:

    3.14 + toFloat (Array.length [ 1, 2, 3 ]) == 6.14

    round 3.14 + Array.length [ 1, 2, 3 ] == 6

**Note:** Languages like Java and JavaScript automatically convert `Int` values
to `Float` values when you mix and match. This can make it difficult to be sure
exactly what type of number you are dealing with. When you try to _infer_ these
conversions (as Scala does) it can be even more confusing. Gren has opted for a
design that makes all conversions explicit.

-}
add : number -> number -> number
add =
    Gren.Kernel.Basics.add


{-| Subtract numbers like `4 - 3 == 1`.

See [`(+)`](#+) for docs on the `number` type variable.

-}
sub : number -> number -> number
sub =
    Gren.Kernel.Basics.sub


{-| Multiply numbers like `2 * 3 == 6`.

See [`(+)`](#+) for docs on the `number` type variable.

-}
mul : number -> number -> number
mul =
    Gren.Kernel.Basics.mul


{-| Floating-point division:

    10 / 4 == 2.5

    11 / 4 == 2.75

    12 / 4 == 3

    13 / 4 == 3.25

    14
        / 4
        == 3.5
        - 1
        / 4
        == -0.25
        - 5
        / 4
        == -1.25

-}
fdiv : Float -> Float -> Float
fdiv =
    Gren.Kernel.Basics.fdiv


{-| Integer division:

    10 // 4 == 2

    11 // 4 == 2

    12 // 4 == 3

    13 // 4 == 3

    14
        // 4
        == 3
        - 1
        // 4
        == 0
        - 5
        // 4
        == -1

Notice that the remainder is discarded, so `3 // 4` is giving output
similar to `truncate (3 / 4)`.

It may sometimes be useful to pair this with the [`remainderBy`](#remainderBy)
function.

-}
idiv : Int -> Int -> Int
idiv =
    Gren.Kernel.Basics.idiv


{-| Exponentiation

    3 ^ 2 == 9

    3 ^ 3 == 27

-}
pow : number -> number -> number
pow =
    Gren.Kernel.Basics.pow


{-| Negate a number.

    negate 42 == -42

    negate -42 == 42

    negate 0 == 0

-}
negate : number -> number
negate n =
    -n


-- INT TO FLOAT / FLOAT TO INT


{-| Convert an integer into a float. Useful when mixing `Int` and `Float`
values like this:

    halfOf : Int -> Float
    halfOf number =
        toFloat number / 2

-}
toFloat : Int -> Float
toFloat =
    Gren.Kernel.Basics.toFloat



-- EQUALITY


{-| Check if values are &ldquo;the same&rdquo;.

**Note:** Gren uses structural equality on tuples, records, and user-defined
union types. This means the values `(3, 4)` and `(3, 4)` are definitely equal.
This is not true in languages like JavaScript that use reference equality on
objects.

**Note:** Do not use `(==)` with functions, JSON values from `gren/json`, or
regular expressions from `gren/regex`. It does not work. It will crash if
possible. With JSON values, decode to Gren values before doing any equality
checks!

Why is it like this? Equality in the Gren sense can be difficult or impossible
to compute. Proving that functions are the same is [undecidable], and JSON
values can come in through ports and have functions, cycles, and new JS data
types that interact weirdly with our equality implementation. In a future
release, the compiler will detect when `(==)` is used with problematic types
and provide a helpful error message at compile time. This will require some
pretty serious infrastructure work, so the stopgap is to crash as quickly as
possible.

[undecidable]: https://en.wikipedia.org/wiki/Undecidable_problem

-}
eq : a -> a -> Bool
eq =
    Gren.Kernel.Utils.equal


{-| Check if values are not &ldquo;the same&rdquo;.

So `(a /= b)` is the same as `(not (a == b))`.

-}
neq : a -> a -> Bool
neq =
    Gren.Kernel.Utils.notEqual



-- COMPARISONS


{-| -}
lt : comparable -> comparable -> Bool
lt =
    Gren.Kernel.Utils.lt


{-| -}
gt : comparable -> comparable -> Bool
gt =
    Gren.Kernel.Utils.gt


{-| -}
le : comparable -> comparable -> Bool
le =
    Gren.Kernel.Utils.le


{-| -}
ge : comparable -> comparable -> Bool
ge =
    Gren.Kernel.Utils.ge


{-| Find the smaller of two comparables.

    min 42 12345678 == 42

    min "abc" "xyz" == "abc"

-}
min : comparable -> comparable -> comparable
min x y =
    if lt x y then
        x

    else
        y


{-| Find the larger of two comparables.

    max 42 12345678 == 12345678

    max "abc" "xyz" == "xyz"

-}
max : comparable -> comparable -> comparable
max x y =
    if gt x y then
        x

    else
        y


{-| Clamps a number within a given range. With the expression
`clamp 100 200 x` the results are as follows:

    100     if x < 100
     x      if 100 <= x < 200
    200     if 200 <= x

-}
clamp : number -> number -> number -> number
clamp low high number =
    if lt number low then
        low

    else if gt number high then
        high

    else
        number


{-| Compare any two comparable values. Comparable values include `String`,
`Char`, `Int`, `Float`, or an array or tuple containing comparable values. These
are also the only values that work as `Dict` keys or `Set` members.

    compare 3 4 == LT

    compare 4 4 == EQ

    compare 5 4 == GT

-}
compare : comparable -> comparable -> Order
compare =
    Gren.Kernel.Utils.compare


{-| Represents the relative ordering of two things.
The relations are less than, equal to, and greater than.
-}
type Order
    = LT
    | EQ
    | GT



-- BOOLEANS


{-| A “Boolean” value. It can either be `True` or `False`.

**Note:** Programmers coming from JavaScript, Java, etc. tend to reach for
boolean values way too often in Gren. Using a [union type][ut] is often clearer
and more reliable. You can learn more about this from Jeremy [here][jf] or
from Richard [here][rt].

[ut]: https://guide.gren-lang.org/types/union_types.html
[jf]: https://youtu.be/6TDKHGtAxeg?t=1m25s
[rt]: https://youtu.be/IcgmSRJHu_8?t=1m14s

-}
type Bool
    = True
    | False


{-| Negate a boolean value.

    not True == False

    not False == True

-}
not : Bool -> Bool
not =
    Gren.Kernel.Basics.not


{-| The logical AND operator. `True` if both inputs are `True`.

    True && True == True

    True && False == False

    False && True == False

    False && False == False

**Note:** When used in the infix position, like `(left && right)`, the operator
short-circuits. This means if `left` is `False` we do not bother evaluating `right`
and just return `False` overall.

-}
and : Bool -> Bool -> Bool
and =
    Gren.Kernel.Basics.and


{-| The logical OR operator. `True` if one or both inputs are `True`.

    True || True == True

    True || False == True

    False || True == True

    False || False == False

**Note:** When used in the infix position, like `(left || right)`, the operator
short-circuits. This means if `left` is `True` we do not bother evaluating `right`
and just return `True` overall.

-}
or : Bool -> Bool -> Bool
or =
    Gren.Kernel.Basics.or


{-| The exclusive-or operator. `True` if exactly one input is `True`.

    xor True True == False

    xor True False == True

    xor False True == True

    xor False False == False

-}
xor : Bool -> Bool -> Bool
xor =
    Gren.Kernel.Basics.xor



-- APPEND


{-| Put two appendable things together. This includes strings and arrays.

    "hello" ++ "world" == "helloworld"

    [ 1, 1, 2 ] ++ [ 3, 5, 8 ] == [ 1, 1, 2, 3, 5, 8 ]

-}
append : appendable -> appendable -> appendable
append =
    Gren.Kernel.Utils.append



-- CRAZY FLOATS


{-| Determine whether a float is an undefined or unrepresentable number.
NaN stands for _not a number_ and it is [a standardized part of floating point
numbers](https://en.wikipedia.org/wiki/NaN).

    isNaN (0 / 0) == True

    isNaN (sqrt -1) == True

    isNaN (1 / 0) == False -- infinity is a number

    isNaN 1 == False

-}
isNaN : Float -> Bool
isNaN =
    Gren.Kernel.Basics.isNaN


{-| Determine whether a float is positive or negative infinity.

    isInfinite (0 / 0) == False

    isInfinite (sqrt -1) == False

    isInfinite (1 / 0) == True

    isInfinite 1 == False

Notice that NaN is not infinite! For float `n` to be finite implies that
`not (isInfinite n || isNaN n)` evaluates to `True`.

-}
isInfinite : Float -> Bool
isInfinite =
    Gren.Kernel.Basics.isInfinite



-- FUNCTION HELPERS


{-| Function composition, passing results along in the suggested direction. For
example, the following code checks if the result of rounding a float is odd:

    not << isEven << round

You can think of this operator as equivalent to the following:

    (g << f) == (\x -> g (f x))

So our example expands out to something like this:

    \n -> not (isEven (round n))

-}
composeL : (b -> c) -> (a -> b) -> (a -> c)
composeL g f =
    \x -> g (f x)


{-| Function composition, passing results along in the suggested direction. For
example, the following code checks if the result of rounding a float is odd:

    round >> isEven >> not

-}
composeR : (a -> b) -> (b -> c) -> (a -> c)
composeR f g =
    \x -> g (f x)


{-| Saying `x |> f` is exactly the same as `f x`.

It is called the “pipe” operator because it lets you write “pipelined” code.
For example, say we have a `sanitize` function for turning user input into
integers:

    -- BEFORE
    sanitize : String -> Maybe Int
    sanitize input =
        String.toInt (String.trim input)

We can rewrite it like this:

    -- AFTER
    sanitize : String -> Maybe Int
    sanitize input =
        input
            |> String.trim
            |> String.toInt

Totally equivalent! I recommend trying to rewrite code that uses `x |> f`
into code like `f x` until there are no pipes left. That can help you build
your intuition.

**Note:** This can be overused! I think folks find it quite neat, but when you
have three or four steps, the code often gets clearer if you break out a
top-level helper function. Now the transformation has a name. The arguments are
named. It has a type annotation. It is much more self-documenting that way!
Testing the logic gets easier too. Nice side benefit!

-}
apR : a -> (a -> b) -> b
apR x f =
    f x


{-| Saying `f <| x` is exactly the same as `f x`.

It can help you avoid parentheses, which can be nice sometimes. Maybe you want
to apply a function to a `case` expression? That sort of thing.

-}
apL : (a -> b) -> a -> b
apL f x =
    f x


{-| Given a value, returns exactly the same value. This is called
[the identity function](https://en.wikipedia.org/wiki/Identity_function).
-}
identity : a -> a
identity x =
    x


{-| A value that can never happen! For context:

  - The boolean type `Bool` has two values: `True` and `False`
  - The unit type `()` has one value: `()`
  - The never type `Never` has no values!

You may see it in the wild in `Html Never` which means this HTML will never
produce any messages. You would need to write an event handler like
`onClick ??? : Attribute Never` but how can we fill in the question marks?!
So there cannot be any event handlers on that HTML.

You may also see this used with tasks that never fail, like `Task Never ()`.

The `Never` type is useful for restricting _arguments_ to a function. Maybe my
API can only accept HTML without event handlers, so I require `Html Never` and
users can give `Html msg` and everything will go fine. Generally speaking, you
do not want `Never` in your return types though.

-}
type Never
    = JustOneMore Never


{-| A function that can never be called. Seems extremely pointless, but it
_can_ come in handy. Imagine you have some HTML that should never produce any
messages. And say you want to use it in some other HTML that _does_ produce
messages. You could say:

    import Html exposing (..)

    embedHtml : Html Never -> Html msg
    embedHtml staticStuff =
        div []
            [ text "hello"
            , Html.map never staticStuff
            ]

So the `never` function is basically telling the type system, make sure no one
ever calls me!

-}
never : Never -> a
never (JustOneMore nvr) =
    never nvr
