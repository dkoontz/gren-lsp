# Story 3.9: Workspace Symbols

## Status
Ready

## Story
**As a** developer,
**I want to** search for symbols across the entire workspace using a query string,
**so that** I can quickly navigate to any function, type, or value definition in my project without knowing the exact file location.

## Acceptance Criteria
- [ ] Handle workspace/symbol requests
- [ ] Search all workspace files for symbols matching query
- [ ] Support fuzzy/relaxed matching as per LSP specification
- [ ] Return WorkspaceSymbol[] with location information
- [ ] Include symbol kind, container name, and optional resolve support
- [ ] Optimize search performance for large workspaces

## Tasks / Subtasks
- [ ] **Implement LSP workspace symbol handler** (AC: 1)
  - [ ] Add `workspace_symbol` method to `gren-lsp-protocol/src/handlers.rs`
  - [ ] Handle `WorkspaceSymbolParams` with query string processing
  - [ ] Return `WorkspaceSymbol[]` (LSP 3.17+) instead of deprecated `SymbolInformation[]`
  - [ ] Support capability registration in server initialization
  - [ ] Handle client capability negotiation for workspace symbol features
- [ ] **Create workspace symbol search engine** (AC: 2, 3)
  - [ ] Create workspace symbol search engine in `gren-lsp-core/src/workspace_symbols.rs`
  - [ ] Implement relaxed/fuzzy matching algorithm as per LSP spec (case-insensitive, character sequence matching)
  - [ ] Search across all indexed symbols in workspace symbol database
  - [ ] Support empty query string to return all workspace symbols
  - [ ] Rank results by relevance (exact matches, then fuzzy matches)
  - [ ] Handle special characters and escape sequences in query strings
- [ ] **Integrate with existing symbol index** (AC: 2, 6)
  - [ ] Leverage existing SQLite symbol index for efficient workspace-wide symbol lookup
  - [ ] Query symbol database with proper filtering and ranking
  - [ ] Use Symbol Model with workspace-level search capabilities
  - [ ] Optimize database queries for performance with large symbol sets
  - [ ] Implement result pagination for workspaces with thousands of symbols
- [ ] **Generate WorkspaceSymbol responses** (AC: 4, 5)
  - [ ] Map Symbol Model to LSP WorkspaceSymbol format
  - [ ] Set proper SymbolKind values for Gren symbols (Function, Enum, Interface, Variable, etc.)
  - [ ] Generate containerName for symbols (module/file context)
  - [ ] Provide full Location with URI and Range information
  - [ ] Support optional data field for resolve operations
  - [ ] Handle symbol visibility (public vs private) in search results
- [ ] **Implement search performance optimizations** (AC: 6)
  - [ ] Add database indexes for efficient symbol name searching
  - [ ] Implement result limiting to prevent overwhelming responses
  - [ ] Cache frequent search queries for improved response time
  - [ ] Use async processing to prevent blocking editor interface
  - [ ] Implement search debouncing for rapid query changes
- [ ] **Add optional resolve support** (AC: 5)
  - [ ] Support `workspaceSymbol/resolve` requests for lazy loading
  - [ ] Implement server capability for resolveProvider
  - [ ] Allow returning WorkspaceSymbol without full location for performance
  - [ ] Resolve additional symbol information on demand
- [ ] **Add comprehensive unit tests for workspace symbols** (AC: All)
  - [ ] Test workspace symbol request handling and response format compliance
  - [ ] Test fuzzy matching algorithm accuracy and performance
  - [ ] Test symbol search across multiple workspace files
  - [ ] Test SymbolKind mapping for different Gren symbol types
  - [ ] Test containerName generation for proper symbol context
  - [ ] Test performance with large workspaces containing many symbols
  - [ ] Test edge cases: empty queries, special characters, non-existent symbols
  - [ ] Test client capability negotiation for workspace symbol features

## Dev Notes

### Previous Story Insights
Story 3.8 (Document Symbols and Outline) established comprehensive symbol extraction from individual documents using tree-sitter AST analysis. The existing Symbol Model and symbol indexing infrastructure provide the foundation for workspace-wide symbol search operations. The SQLite symbol database enables efficient cross-file symbol lookup required for workspace symbol functionality.

### Data Models
**WorkspaceSymbol Model**: [Source: docs/lsp-spec/3.18/workspace/symbol.md#workspaceSymbol]
- WorkspaceSymbol represents symbols searchable across the entire workspace
- Must set `name` (symbol identifier), `kind` (SymbolKind), and `location` (URI + Range)
- Supports `containerName` for providing module/file context to users
- Supports `tags` for marking deprecated symbols (using SymbolTag.Deprecated)
- Supports optional `data` field for lazy resolution via workspaceSymbol/resolve

**SymbolKind Mapping**: [Source: docs/lsp-spec/3.18/workspace/symbol.md#symbolKind]
- Function (12) - Gren function definitions
- Enum (10) - Gren union types  
- EnumMember (22) - Gren union type constructors
- Interface (11) - Gren type aliases
- Variable (13) - Gren value bindings
- Constant (14) - Gren immutable values
- Module (2) - Gren module declarations

**Symbol Model**: [Source: docs/architecture/data-models.md#symbol-model]
- Enhanced for workspace-wide searching with cross-file relationships  
- `location` provides precise source position for navigation
- `kind` maps to appropriate LSP SymbolKind values
- `references` array enables comprehensive workspace symbol tracking

### API Specifications
**LSP Protocol Methods**: [Source: docs/lsp-spec/3.18/workspace/symbol.md]
- `workspace/symbol` - Request workspace symbols matching query, returns WorkspaceSymbol[]
- `workspaceSymbol/resolve` - Optional resolve request for lazy loading additional symbol information
- Server capabilities: workspaceSymbolProvider with optional resolveProvider support
- Client capability: workspace.symbol determines feature availability and query handling

**Symbol Index Integration**: [Source: docs/architecture/components.md#symbol-index]
- SQLite database provides persistent symbol storage across workspace files
- `find_symbol(name: &str) -> Vec<Symbol>` enables efficient symbol search
- Custom indexing algorithms optimized for Gren syntax and symbol patterns

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Existing handlers.rs structure provides template for workspace symbol method implementation
- JSON-RPC communication pattern established for handling WorkspaceSymbolParams
- Response formatting capabilities support WorkspaceSymbol array generation

**Symbol Index Component**: [Source: docs/architecture/components.md#symbol-index]
- SQLite-backed symbol database enables workspace-wide symbol search
- Searchable database interface supports fuzzy matching and relevance ranking
- Integration with Analysis Engine provides up-to-date symbol information

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main workspace symbol method implementation location
**Workspace Symbol Engine**: `/gren-lsp-core/src/workspace_symbols.rs` - New module for workspace symbol search logic
**Testing**: `/gren-lsp-protocol/tests/workspace_symbol_tests.rs` - Integration tests for workspace symbols
**Unit Tests**: Individual `mod.rs` files with `#[cfg(test)]` modules alongside implementations

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` for symbol search logic validation
- Integration tests in `/tests/` directories for LSP protocol compliance
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace
- Performance testing with `criterion` for workspace symbol search benchmarks

**Specific Test Cases Required**:
- Workspace symbol request parsing and WorkspaceSymbol response format compliance
- Fuzzy matching algorithm accuracy for various query patterns and symbol names
- Symbol search completeness across multiple workspace files and modules
- SymbolKind mapping correctly represents Gren language constructs in workspace context
- ContainerName generation provides meaningful symbol context for navigation
- Performance characteristics with large workspaces containing thousands of symbols
- Edge case handling: empty queries, special characters, malformed queries
- Client capability negotiation for workspace symbol and resolve support features

### Technical Constraints

**⚠️ CRITICAL: Tree-sitter AST Requirement**: [Source: docs/architecture/tree-sitter-ast-structure.md]
- **MANDATORY**: All workspace symbol indexing MUST use tree-sitter AST for accurate symbol identification
- **NEVER**: Use text-based parsing (regex, string matching) for symbol extraction or search
- **Tree-sitter Queries**: Symbol indexing must use proper node analysis from comprehensive AST structure
- **Symbol Context**: Use AST-based context determination for containerName and location accuracy
- **Reference**: See comprehensive AST structure guide and examples in tree-sitter architecture document

**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **Pure functional benefits**: All symbols are immutable, making workspace-wide caching safe and predictable
- **Small Language Syntax Benefits**: Limited constructs mean comprehensive symbol search is feasible with existing Symbol Model
- **Array-First Data Model**: Efficient symbol storage aligns with performance requirements for large workspace search
- **No-exception error model**: All error cases explicit in types, enabling robust workspace symbol search even with parsing errors

**Performance Considerations**: [Source: docs/architecture/performance-considerations.md]
- **Async Processing**: Non-blocking request handling essential for workspace symbol search responsiveness
- **Request Prioritization**: Workspace symbol search as interactive navigation feature requires optimized response time
- **LRU Caching**: Bounded memory usage for search results and symbol caching
- **Symbol Index Persistence**: SQLite database provides fast symbol lookup across workspace restarts

**Database Optimization**: [Source: docs/architecture/components.md#symbol-index]
- SQLite indexing strategies for efficient symbol name searching and fuzzy matching
- Result pagination prevents overwhelming responses with thousands of matching symbols
- Query optimization for workspace-wide symbol searches with proper filtering

### Performance Considerations
**Search Algorithm Optimization**: [Source: docs/architecture/performance-considerations.md]
- **Fuzzy Matching Performance**: Implement efficient string matching algorithms for relaxed query processing
- **Database Query Optimization**: Use proper indexes and query strategies for fast symbol lookup
- **Result Limiting**: Prevent excessive response sizes that could impact editor performance
- **Search Debouncing**: Handle rapid query changes without overwhelming the search system

**Memory Management**: [Source: docs/architecture/performance-considerations.md#memory-management]
- LRU caching for frequent search queries and results
- Bounded result sets to prevent memory exhaustion with large workspaces
- Efficient data structures for symbol storage and search operations

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/workspace_symbol_tests.rs`
- Performance tests: `gren-lsp-protocol/benches/workspace_symbol_bench.rs`
- Search engine tests: `gren-lsp-core/src/workspace_symbols.rs` - `#[cfg(test)]` modules

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace and symbol index using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual Gren files
- Follow Rust testing conventions with descriptive test names
- Performance benchmarks using `criterion` crate for search algorithm evaluation

### Specific Testing Requirements:
- Test workspace symbol request handling and WorkspaceSymbol response format compliance
- Test fuzzy matching algorithm accuracy and performance with various query patterns
- Test symbol search completeness across multiple workspace files and different symbol types
- Test SymbolKind mapping correctness for Gren-specific language constructs
- Test containerName generation provides meaningful context for symbol navigation
- Test performance characteristics with large workspaces containing extensive symbol definitions
- Test edge case handling: empty queries, special characters, malformed or non-existent symbols
- Test client capability negotiation for workspace symbol and optional resolve features
- Test optional resolve functionality for lazy loading of symbol information
- Test search result ranking and relevance scoring for user experience optimization

## Project Structure Notes

The existing symbol indexing infrastructure with SQLite database provides the foundation for efficient workspace-wide symbol search. The LSP protocol handler patterns established in previous stories enable straightforward implementation of workspace symbol requests. The Symbol Model and tree-sitter integration support comprehensive symbol extraction required for accurate workspace symbol search results.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 9 | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*