# Story 3.10: Manual VS Code Integration Testing and Epic 3 Completion

## Status
Ready

## Story
**As a** Gren developer using VS Code,
**I want to** have all Epic 3 advanced features working reliably in an integrated environment,
**so that** I can confidently use the Gren LSP for professional development with seamless editor integration.

## Acceptance Criteria
- [ ] Complete manual testing of all Epic 3 features in VS Code
- [ ] Verify type checking errors display accurately from Gren compiler
- [ ] Confirm rename refactoring works across multiple files
- [ ] Validate find all references shows complete usage
- [ ] Test import management suggests and organizes imports correctly
- [ ] Verify code formatting applies Gren style consistently
- [ ] Confirm code actions provide useful quick fixes
- [ ] Test document symbols populate outline view correctly
- [ ] Validate workspace symbols enable global search
- [ ] Ensure performance remains responsive with all features enabled
- [ ] Create comprehensive integration test suite
- [ ] Document any discovered issues and their resolutions

## Tasks / Subtasks
- [ ] **Setup comprehensive test workspace** (AC: 1, 10)
  - [ ] Create multi-file Gren project with diverse code patterns
  - [ ] Include files with type errors, syntax issues, and valid code
  - [ ] Set up project with imports, exports, and module dependencies
  - [ ] Create test scenarios covering all Epic 3 feature combinations
  - [ ] Prepare test data with various symbol types and references
- [ ] **Test type checking and diagnostics integration** (AC: 2)
  - [ ] Verify compiler errors display with proper range highlighting
  - [ ] Test type error messages match compiler output
  - [ ] Confirm diagnostic severity levels (Error, Warning, Info) display correctly
  - [ ] Test real-time diagnostics update on file changes
  - [ ] Verify diagnostics clear when errors are fixed
  - [ ] Test performance with large files containing multiple errors
- [ ] **Test rename refactoring functionality** (AC: 3)
  - [ ] Test rename of function definitions across multiple files
  - [ ] Verify module-qualified name renaming works correctly
  - [ ] Test rename of type definitions and constructors
  - [ ] Confirm rename operation atomicity (all or nothing)
  - [ ] Test rename preview functionality in VS Code
  - [ ] Verify rename respects scope and shadowing rules
- [ ] **Test find all references feature** (AC: 4)
  - [ ] Test reference finding for functions, types, and values
  - [ ] Verify direct and qualified references are found
  - [ ] Test references across multiple workspace files
  - [ ] Confirm reference results include proper location information
  - [ ] Test performance with large workspace symbol sets
  - [ ] Verify references exclude definition when appropriate
- [ ] **Test import management capabilities** (AC: 5)
  - [ ] Test automatic import suggestions for unresolved symbols
  - [ ] Verify import organization and alphabetical sorting
  - [ ] Test unused import removal functionality
  - [ ] Confirm exposing list handling in import statements
  - [ ] Test import quick fix code actions
  - [ ] Verify module path resolution accuracy
- [ ] **Test code formatting integration** (AC: 6)
  - [ ] Test format on save functionality
  - [ ] Verify entire document formatting preserves semantics
  - [ ] Test range formatting for selected code blocks
  - [ ] Confirm formatting handles malformed code gracefully
  - [ ] Test formatting configuration options
  - [ ] Verify formatting idempotency (multiple applications produce same result)
- [ ] **Test code actions and quick fixes** (AC: 7)
  - [ ] Test quick fixes for common type errors
  - [ ] Verify missing type annotation suggestions
  - [ ] Test case expression generation for custom types
  - [ ] Confirm extract function refactoring actions
  - [ ] Test contextual code action availability
  - [ ] Verify code action application correctness
- [ ] **Test document symbols and outline** (AC: 8)
  - [ ] Test symbol hierarchy display in VS Code outline
  - [ ] Verify all function, type, and value symbols appear
  - [ ] Test symbol navigation from outline view
  - [ ] Confirm breadcrumb navigation functionality
  - [ ] Test dynamic outline updates on file changes
  - [ ] Verify nested definition handling
- [ ] **Test workspace symbols functionality** (AC: 9)
  - [ ] Test global symbol search across workspace
  - [ ] Verify fuzzy matching algorithm accuracy
  - [ ] Test symbol search performance with large workspaces
  - [ ] Confirm proper symbol kind and container name display
  - [ ] Test empty query handling (show all symbols)
  - [ ] Verify workspace symbol navigation functionality
- [ ] **Performance and responsiveness testing** (AC: 10)
  - [ ] Test LSP server startup time with large workspaces
  - [ ] Monitor memory usage during extended editing sessions
  - [ ] Test response times for interactive features (completion, hover)
  - [ ] Verify background analysis doesn't block editor interface
  - [ ] Test concurrent request handling accuracy
  - [ ] Monitor CPU usage during intensive analysis operations
- [ ] **Create automated integration test suite** (AC: 11)
  - [ ] Develop VS Code extension integration tests
  - [ ] Create LSP protocol compliance tests for all Epic 3 features
  - [ ] Implement performance benchmark tests
  - [ ] Add multi-file workspace scenario tests
  - [ ] Create regression tests for discovered issues
  - [ ] Set up continuous integration for integration tests
- [ ] **Document findings and create completion report** (AC: 12)
  - [ ] Document all tested scenarios and results
  - [ ] Record performance benchmarks and system requirements
  - [ ] Create issue reports for any discovered problems
  - [ ] Document workarounds for known limitations
  - [ ] Prepare Epic 3 completion summary
  - [ ] Update user documentation with tested feature descriptions

## Dev Notes

### Previous Story Insights
Story 3.9 (Workspace Symbols) completed the final individual feature implementation for Epic 3, establishing workspace-wide symbol search using the SQLite symbol database and fuzzy matching algorithms. All Epic 3 advanced features are now implemented individually, requiring comprehensive integration testing to ensure they work together reliably in the VS Code environment. The Symbol Model and LSP protocol handlers provide a solid foundation for integrated feature testing.

### Data Models
**Integration Testing Model**: [Source: docs/architecture/data-models.md#workspace-model]
- Workspace Model coordinates all Epic 3 features through shared symbol database
- SourceFile Model manages document state across multiple LSP operations simultaneously
- Symbol Model enables cross-feature operations (rename → find references → workspace symbols)
- Diagnostic Model handles error reporting from multiple analysis sources

**VS Code LSP Client Integration**: [Source: docs/lsp-spec/3.18/general/initialize.md]
- Client capabilities determine which Epic 3 features are available for testing
- Server capabilities must advertise all implemented Epic 3 features correctly
- Dynamic registration enables testing of optional features like resolve operations
- Workspace folders configuration affects multi-file testing scenarios

### API Specifications
**LSP Protocol Methods for Integration Testing**: [Source: docs/lsp-spec/3.18/]
- `textDocument/rename` → `textDocument/references` → `workspace/symbol` integration flow
- `textDocument/codeAction` → `workspace/applyEdit` for code fix application
- `textDocument/formatting` → `textDocument/didChange` → diagnostics update cycle
- `textDocument/documentSymbol` → `workspace/symbol` consistency validation
- All methods must handle concurrent requests without state corruption

**Compiler Integration Testing**: [Source: docs/architecture/external-apis.md#gren-compiler-integration]
- CLI compiler execution produces consistent diagnostic output
- Process management handles compiler timeouts and failures gracefully
- Output parsing correctly maps compiler errors to LSP diagnostic ranges
- Incremental compilation optimizations maintain accuracy

### Component Specifications
**VS Code Extension Integration**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Extension communicates via JSON-RPC over stdio with LSP server
- All Epic 3 features must register proper client/server capabilities
- Configuration changes trigger appropriate feature reinitialization
- Error handling provides meaningful feedback to VS Code users

**Multi-Component Integration**: [Source: docs/architecture/components.md]
- Analysis Engine coordinates with Symbol Index for cross-file operations
- File System Monitor triggers updates across all Epic 3 features consistently
- Code Completion Provider integrates with symbol information from rename/references
- All components must handle concurrent access to shared SQLite database

### File Locations
**Integration Test Files**: `/gren-lsp-protocol/tests/integration_tests.rs` - Comprehensive Epic 3 integration tests
**VS Code Test Workspace**: `/test-workspace/` - Multi-file Gren project for manual testing
**Performance Tests**: `/gren-lsp-core/benches/integration_bench.rs` - Performance validation for integrated features
**Documentation**: `/docs/manual-testing-guide.md` - Manual testing procedures and checklists

### Testing Requirements
**Manual Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- VS Code extension testing with real Gren projects and user scenarios
- Performance monitoring using built-in VS Code developer tools
- Multi-file workspace testing with various project sizes and complexities
- User experience validation for all Epic 3 feature combinations

**Automated Integration Testing**:
- Integration tests in `/tests/` directories using `cargo test` framework
- VS Code extension testing using vscode-test framework
- LSP protocol compliance testing with custom test harnesses
- Performance benchmarking using `criterion` crate for regression detection

**Specific Test Scenarios Required**:
- Cross-feature integration: rename → find references → workspace symbols workflow
- Concurrent operations: multiple LSP requests during background analysis
- Large workspace handling: Epic 3 features with hundreds of Gren files
- Error recovery: feature functionality during compiler integration failures
- Configuration changes: dynamic feature enabling/disabling during VS Code sessions
- Memory and performance: sustained Epic 3 usage without degradation

### Technical Constraints

**⚠️ CRITICAL: Tree-sitter AST Requirement**: [Source: docs/architecture/tree-sitter-ast-structure.md]
- **MANDATORY**: All Epic 3 features must use tree-sitter AST for symbol analysis and context determination
- **NEVER**: Use text-based parsing for any feature - all symbol operations must be AST-based
- **Integration Testing**: Verify all features properly use tree-sitter queries for accurate results
- **Reference**: All Epic 3 features must follow tree-sitter architecture requirements for reliability

**VS Code Integration Requirements**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **Pure Functional Benefits**: Immutable analysis state enables safe concurrent testing
- **Deterministic Analysis**: Repeatable test results due to referential transparency
- **Array-First Performance**: Efficient workspace operations support large-scale testing
- **Effect Transparency**: Clear error handling enables comprehensive failure testing

**Performance Testing Constraints**: [Source: docs/architecture/performance-considerations.md]
- **Memory Management**: LRU caching must maintain bounds during extended testing
- **Async Processing**: Non-blocking operations required for responsive VS Code integration
- **Request Prioritization**: Interactive features maintain responsiveness during background analysis
- **Startup Optimization**: Symbol index persistence enables fast test workspace initialization

**Integration Complexity Management**: [Source: docs/architecture/error-handling-strategy.md]
- **Graceful Degradation**: Epic 3 features continue operating when individual components fail
- **Error Recovery**: Comprehensive error handling across all feature integration points
- **Diagnostic Reporting**: Clear error messages for both LSP internal issues and user-facing problems

### Performance Considerations
**Integration Performance Testing**: [Source: docs/architecture/performance-considerations.md]
- **Multi-Feature Load Testing**: Simultaneous use of rename, references, and workspace symbols
- **Memory Usage Monitoring**: SQLite database growth and LRU cache effectiveness during extended sessions
- **Response Time Validation**: Interactive features maintain sub-100ms response times
- **Background Analysis Impact**: Compiler integration doesn't block user interactions

**Scalability Testing Requirements**:
- Test workspace with 50+ Gren files and 1000+ symbols
- Concurrent LSP requests during active editing sessions
- Symbol database query performance with large datasets
- Memory consumption during intensive refactoring operations

## Testing
### Test File Locations:
- Integration tests: `gren-lsp-protocol/tests/epic3_integration_tests.rs`
- VS Code extension tests: `vscode-extension/src/test/suite/epic3.test.ts`
- Performance tests: `gren-lsp-core/benches/epic3_integration_bench.rs`
- Manual test workspace: `test-workspace/` - Multi-file Gren project

### Testing Standards:
- Manual testing follows documented procedures in `/docs/manual-testing-guide.md`
- Automated tests use `cargo test` for Rust components and `npm test` for VS Code extension
- Performance benchmarks using `criterion` establish baseline metrics
- Integration tests validate LSP protocol compliance for all Epic 3 features

### Specific Testing Requirements:
- Manual VS Code testing covers all Epic 3 Definition of Done scenarios
- Cross-feature integration testing ensures features work together correctly
- Performance testing validates responsiveness with all features enabled
- Error handling testing confirms graceful degradation when components fail
- Large workspace testing validates scalability of integrated feature set
- User experience testing confirms intuitive operation of combined features
- Regression testing prevents issues when features interact unexpectedly
- Configuration testing validates proper feature enabling/disabling in VS Code
- Multi-session testing ensures state consistency across editor restarts
- Documentation testing confirms all features work as described in user guides

## Project Structure Notes

The integration testing builds upon the complete Epic 3 feature set, requiring coordination between all LSP protocol handlers, the Analysis Engine, Symbol Index, and VS Code extension components. The existing SQLite database and Symbol Model provide the foundation for testing cross-feature workflows like rename → find references → workspace symbols. The manual testing approach validates real-world usage scenarios that automated tests cannot fully capture.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 10 - Final integration testing | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*