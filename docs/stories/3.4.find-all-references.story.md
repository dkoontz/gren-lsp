# Story 3.4: Find All References

## Status
Ready

## Story
**As a** developer,
**I want to** locate all usages of a symbol throughout the workspace,
**so that** I can understand code dependencies and navigate between related code locations efficiently.

## Acceptance Criteria
- [ ] Handle textDocument/references requests
- [ ] Search all files for symbol usage
- [ ] Include direct and qualified references
- [ ] Distinguish declarations from references
- [ ] Support filtering by reference type
- [ ] Optimize search performance

## Tasks / Subtasks
- [ ] **Implement LSP references request handler** (AC: 1)
  - [ ] Update `references` method in `gren-lsp-protocol/src/handlers.rs` to handle ReferenceParams
  - [ ] Extract symbol at cursor position using existing `find_symbol_at_position` method
  - [ ] Validate that symbol exists and return appropriate error for non-existent symbols
- [ ] **Implement comprehensive workspace symbol search** (AC: 2, 3)
  - [ ] Extend `find_symbol` in Symbol Index to return all symbol occurrences
  - [ ] Search through all workspace files using existing `source_files` HashMap
  - [ ] Handle both qualified (`Module.symbol`) and unqualified (`symbol`) references
  - [ ] Use tree-sitter parsing to identify exact symbol boundaries and contexts
- [ ] **Support declaration vs reference distinction** (AC: 4)
  - [ ] Identify symbol definitions vs usages using AST node types
  - [ ] Include declaration in results when `ReferenceParams.include_declaration` is true
  - [ ] Mark declaration locations with special context information
- [ ] **Implement reference type filtering** (AC: 5)
  - [ ] Support filtering by reference context (function calls, type annotations, import statements)
  - [ ] Use tree-sitter node types to categorize reference contexts
  - [ ] Return structured Location data with reference type metadata
- [ ] **Optimize search performance** (AC: 6)
  - [ ] Leverage SQLite symbol index for efficient cross-file searches
  - [ ] Use indexed symbol storage to avoid full-text search when possible
  - [ ] Implement result caching for frequently accessed symbols
  - [ ] Batch file processing to reduce I/O overhead
- [ ] **Add unit tests for references functionality** (AC: All)
  - [ ] Test local symbol references within single file
  - [ ] Test cross-file references with imports and qualified names
  - [ ] Test declaration inclusion/exclusion based on parameters
  - [ ] Test reference type filtering and categorization
  - [ ] Test performance with large codebases and many references
  - [ ] Test error handling for non-existent symbols and malformed requests

## Dev Notes

### Previous Story Insights
Story 3.3 (Rename Refactoring) established the foundation for symbol finding and workspace-wide operations. The existing infrastructure includes symbol indexing, reference tracking, and cross-file search capabilities that can be leveraged for comprehensive reference finding.

### Data Models
**Symbol Model**: [Source: docs/architecture/data-models.md#symbol-model]
- Symbol references are stored as `Array<Location>` 
- Symbols have `visibility` field (Public, private, module-internal) for scope-aware reference filtering
- Symbol locations include precise file/line/column data for accurate navigation
- Symbol names include `kind` field to distinguish functions, types, constructors, etc.
- `references: Array<Location>` field already tracks all usage locations for efficient lookup

**Workspace Model**: [Source: docs/architecture/data-models.md#workspace-model]
- Maintains `symbol_index: SymbolIndex` for global symbol database with cross-file operations
- Stores `source_files: HashMap<PathBuf, SourceFile>` for accessing document content during search
- Symbol index uses SQLite backend for efficient reference lookups across large codebases

### API Specifications
**LSP Protocol Methods**: [Source: docs/architecture/external-apis.md#language-server-protocol-specification]
- `textDocument/references` - Main references request handler returning Location array
- Must handle ReferenceParams with textDocument URI, position, and ReferenceContext
- ReferenceContext.includeDeclaration determines if symbol definition should be included
- Return Vec<Location> with all matching symbol usages across the workspace

**Symbol Index Interface**: [Source: docs/architecture/components.md#symbol-index]
- `find_symbol(name: &str) -> Vec<Symbol>` - Symbol search capability already implemented
- `get_references(symbol: Symbol) -> Vec<Location>` - Reference finding interface ready for implementation
- SQLite backend provides efficient cross-file symbol lookups with indexing

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Current `references` method in `handlers.rs` likely needs implementation
- Existing infrastructure for symbol finding via `find_symbol_at_position` method
- Import-aware symbol resolution through `find_qualified_symbol` and `find_unqualified_symbol`

**Analysis Engine Integration**: [Source: docs/architecture/components.md#analysis-engine]
- Workspace maintains document content for comprehensive file searching
- Existing symbol indexing provides foundation for efficient reference finding
- Tree-sitter parsing ensures accurate symbol boundary detection and context identification

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main references implementation location
**Core Analysis**: `/gren-lsp-core/src/symbol.rs` - Symbol model and indexing logic for reference storage
**Testing**: `/gren-lsp-protocol/tests/` - Integration tests for LSP references functionality
**Unit Tests**: `/gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules alongside implementation

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` with mockall for workspace mocking
- Integration tests in `/tests/` directories for cross-file reference scenarios
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace
- Performance testing with `criterion` for large codebase reference searches

**Specific Test Cases Required**:
- Single-file symbol references (local functions, types, variables)
- Cross-file references with explicit imports (`import Module exposing (symbol)`)
- Module-qualified references (`Module.symbol` usages)
- Declaration inclusion/exclusion based on ReferenceParams.context.includeDeclaration
- Reference type filtering (function calls vs type annotations vs imports)
- Performance benchmarks for large codebases with many symbol references

### Technical Constraints
**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **No polymorphic overloading**: Function names are unique within scope, enabling precise reference identification
- **Deterministic imports**: Explicit import statements with no ambiguity - each reference has clear origin
- **Pure functional**: No side effects enable safe reference analysis without state concerns
- **Array-first data model**: Use arrays for storing reference locations for better cache performance

**Error Handling Strategy**: [Source: docs/architecture/error-handling-strategy.md#graceful-degradation]
- **Critical requirement**: Provide accurate reference results - better to return partial results than incorrect locations
- Implement graceful degradation for partial analysis failures (some files may be unparseable)
- Use structured error reporting with precise diagnostic information for search failures

### Performance Considerations
**Symbol Index Optimization**: [Source: docs/architecture/performance-considerations.md]
- **LRU Caching**: Bounded memory usage for frequently accessed reference results
- **Incremental Analysis**: Only re-index changed files to maintain reference accuracy
- **Async Processing**: Non-blocking request handling for editor responsiveness during large searches
- **Request Prioritization**: Reference searches prioritized as interactive operations

**Search Optimization**: [Source: docs/architecture/data-models.md#workspace-model]
- SQLite database provides efficient symbol lookups with proper indexing
- Array-based reference storage aligns with Gren's performance characteristics
- Incremental parsing minimizes reanalysis overhead during workspace changes

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/references_tests.rs`
- Performance tests: `gren-lsp-protocol/benches/references_bench.rs`
- Mock workspace setup: Use `tempfile` and `mockall` crates

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual files
- Follow Rust testing conventions with descriptive test names
- Performance benchmarks using `criterion` crate

### Specific Testing Requirements:
- Test reference finding accuracy across file boundaries
- Test qualified vs unqualified reference distinction
- Test declaration inclusion/exclusion functionality
- Test reference type categorization and filtering
- Test performance with large workspaces (>1000 files, >10000 symbols)
- Test error handling for malformed requests and non-existent symbols
- Test incremental updates when files change

## Project Structure Notes
The existing LSP handler implementation provides a solid foundation with symbol finding capabilities already established. The references functionality can leverage the existing symbol index, tree-sitter parsing, and workspace management infrastructure. The `find_symbol_at_position` method provides the starting point for identifying the target symbol, while the symbol index's reference tracking can be expanded to support comprehensive workspace-wide searches.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 4 | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*