# Story 3.6: Code Formatting Integration

## Status
Ready

## Story
**As a** developer,
**I want to** format Gren code automatically according to language conventions,
**so that** I can maintain consistent code style and improve readability without manually managing formatting rules.

## Acceptance Criteria
- [ ] Handle textDocument/formatting requests
- [ ] Format entire documents on request
- [ ] Support range formatting
- [ ] Preserve semantic meaning
- [ ] Configure formatting options
- [ ] Integrate with format-on-save

## Tasks / Subtasks
- [ ] **Implement LSP document formatting handler** (AC: 1, 2)
  - [ ] Add `document_formatting` method to `gren-lsp-protocol/src/handlers.rs`
  - [ ] Handle `DocumentFormattingParams` with `FormattingOptions` parsing
  - [ ] Return `TextEdit[]` array for document-wide formatting changes
  - [ ] Support capability registration in server initialization
- [ ] **Implement range formatting support** (AC: 3)
  - [ ] Add `document_range_formatting` method to handlers
  - [ ] Handle `DocumentRangeFormattingParams` with specific Range parameter
  - [ ] Generate targeted TextEdits for specified range only
  - [ ] Support multiple ranges formatting (LSP 3.18.0 extension)
- [ ] **Create Gren code formatter engine** (AC: 2, 4)
  - [ ] Design basic Gren formatter in `gren-lsp-core/src/formatter.rs`
  - [ ] Use tree-sitter AST for semantic-aware formatting
  - [ ] Implement indentation rules (2-space default, configurable)
  - [ ] Format function definitions, type annotations, and expressions
  - [ ] Handle import statement formatting and organization
  - [ ] Ensure idempotent formatting (multiple applications produce same result)
- [ ] **Implement formatting options configuration** (AC: 5)
  - [ ] Parse standard `FormattingOptions` (tabSize, insertSpaces, trimTrailingWhitespace)
  - [ ] Support Gren-specific formatting preferences as custom options
  - [ ] Handle insertFinalNewline and trimFinalNewlines options
  - [ ] Validate formatting configuration and provide defaults
- [ ] **Integrate with format-on-save workflow** (AC: 6)
  - [ ] Register formatting capabilities in server initialization
  - [ ] Handle client formatting requests triggered by save events
  - [ ] Ensure async processing doesn't block editor operations
  - [ ] Support conditional formatting based on file size limits
- [ ] **Add comprehensive unit tests for formatting functionality** (AC: All)
  - [ ] Test document formatting with various Gren syntax structures
  - [ ] Test range formatting preserves surrounding code
  - [ ] Test formatting options configuration and application
  - [ ] Test idempotent formatting behavior
  - [ ] Test semantic preservation (AST comparison before/after)
  - [ ] Test format-on-save integration scenarios
  - [ ] Test error handling for malformed code
  - [ ] Test performance with large files

## Dev Notes

### Previous Story Insights
Story 3.5 (Import Management) established the foundation for code manipulation through TextEdit generation and workspace document management. The existing tree-sitter parsing infrastructure and AST manipulation capabilities provide the core functionality needed for semantic-aware code formatting. The LSP handler patterns in `handlers.rs` demonstrate the structure for implementing new protocol methods.

### Data Models
**TextEdit Model**: [Source: docs/lsp-spec/3.18/types/textEdit.md]
- TextEdit operations specify Range and newText for precise document modifications
- Multiple TextEdits can be applied atomically for comprehensive formatting changes
- Range-based edits preserve concurrent editing compatibility in LSP protocol

**FormattingOptions Model**: [Source: docs/lsp-spec/3.18/language/formatting.md#formattingOptions]
- Standard options include tabSize (spaces per tab), insertSpaces (prefer spaces over tabs)
- Optional features: trimTrailingWhitespace, insertFinalNewline, trimFinalNewlines
- Custom properties supported via string indexer for Gren-specific formatting rules

### API Specifications
**LSP Protocol Methods**: [Source: docs/lsp-spec/3.18/language/formatting.md]
- `textDocument/formatting` - Format entire document, returns TextEdit[] or null
- `textDocument/rangeFormatting` - Format specific range, accepts Range parameter
- `textDocument/rangesFormatting` - Format multiple ranges (LSP 3.18.0+)
- Server capabilities: documentFormattingProvider, documentRangeFormattingProvider

**Tree-sitter Integration**: [Source: docs/architecture/external-apis.md#tree-sitter-grammar-integration]
- `ts_parser_parse()` provides semantic AST for context-aware formatting
- Tree-sitter queries enable identification of syntax elements for formatting rules
- Incremental parsing supports efficient formatting of changed regions

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Existing handlers.rs structure provides template for formatting method implementation
- JSON-RPC communication pattern established for handling DocumentFormattingParams
- WorkspaceEdit generation capabilities available for TextEdit array construction

**Analysis Engine Integration**: [Source: docs/architecture/components.md#analysis-engine]
- Tree-sitter parsing provides accurate syntax tree for formatting decisions
- AST node traversal enables systematic formatting rule application
- Document management supports safe text modification and version tracking

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main formatting implementation location
**Core Formatter**: `/gren-lsp-core/src/formatter.rs` - New module for formatting engine logic
**Testing**: `/gren-lsp-protocol/tests/formatting_tests.rs` - Integration tests for formatting functionality
**Unit Tests**: `/gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules alongside implementation

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` for formatting logic validation
- Integration tests in `/tests/` directories for LSP protocol compliance
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace
- Performance testing with `criterion` for formatting operation benchmarks

**Specific Test Cases Required**:
- Document formatting preserves semantic correctness through AST comparison
- Range formatting maintains proper indentation context at boundaries
- Formatting options application (spaces vs tabs, line endings, whitespace trimming)
- Idempotent behavior verification (format(format(code)) === format(code))
- Format-on-save integration with editor save events
- Error handling for syntactically invalid code
- Performance benchmarks for large file formatting operations

### Technical Constraints

**⚠️ CRITICAL: Tree-sitter AST Requirement**: [Source: docs/architecture/tree-sitter-ast-structure.md]
- **MANDATORY**: All code formatting MUST use tree-sitter AST analysis for semantic understanding
- **NEVER**: Use text-based parsing (regex, string matching) for formatting decisions
- **Tree-sitter Queries**: Use proper node traversal: `(value_declaration)`, `(type_declaration)`, `(record_expr)`, etc.
- **Semantic Formatting**: Use AST structure to understand code semantics for proper formatting
- **Reference**: See comprehensive AST structure guide and examples in tree-sitter architecture document

**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **Small Language Syntax Benefits**: Minimal syntax means comprehensive formatting rules can be implemented efficiently
- **Pure functional**: No side effects enable safe formatting operations without runtime concerns
- **Array-first data model**: Use arrays for storing formatting rules and TextEdit operations for better performance
- **Deterministic parsing**: Tree-sitter provides reliable AST structure for consistent formatting results

**Error Handling Strategy**: [Source: docs/architecture/error-handling-strategy.md#graceful-degradation]
- **Critical requirement**: Formatting must preserve semantic meaning - never generate syntactically invalid code
- Implement graceful degradation for partial formatting when AST parsing fails on malformed code
- Use structured error reporting for formatting failures with clear diagnostic messages
- Provide fallback to basic indentation/whitespace formatting when full semantic formatting unavailable

### Performance Considerations
**Formatting Operation Optimization**: [Source: docs/architecture/performance-considerations.md]
- **Async Processing**: Non-blocking request handling for editor responsiveness during formatting operations
- **Request Prioritization**: Format-on-save operations prioritized as interactive user actions
- **Incremental Formatting**: Range formatting minimizes processing overhead for large files
- **Memory Management**: Bounded memory usage for AST processing and TextEdit generation

**Tree-sitter Performance**: [Source: docs/architecture/data-models.md#sourcefile-model]
- Tree-sitter incremental parsing minimizes reanalysis overhead for formatting operations
- AST node caching reduces traversal costs for repeated formatting requests
- Range-based queries optimize performance for partial document formatting

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/formatting_tests.rs`
- Performance tests: `gren-lsp-protocol/benches/formatting_bench.rs`
- Formatter logic tests: `gren-lsp-core/src/formatter.rs` - `#[cfg(test)]` modules

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual Gren files
- Follow Rust testing conventions with descriptive test names
- Performance benchmarks using `criterion` crate

### Specific Testing Requirements:
- Test formatting accuracy across all Gren syntax constructs (functions, types, imports, expressions)
- Test range formatting boundary conditions and context preservation
- Test formatting options configuration and edge case handling
- Test idempotent behavior with multiple formatting applications
- Test semantic preservation through pre/post AST comparison
- Test format-on-save workflow integration with editor events
- Test error handling for malformed code and graceful degradation
- Test performance with large files (>1000 lines) and complex syntax structures

## Project Structure Notes

The existing LSP handler implementation provides a solid foundation with established patterns for protocol method implementation, TextEdit generation, and workspace document management. The tree-sitter parsing infrastructure enables semantic-aware formatting decisions through accurate AST analysis. The formatting functionality can leverage existing document management for safe text modifications and the Symbol Index for context-aware formatting rules. Integration with the established testing framework ensures comprehensive validation of formatting behavior.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 6 | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*