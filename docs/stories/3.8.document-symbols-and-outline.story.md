# Story 3.8: Document Symbols and Outline

## Status
Ready

## Story
**As a** developer,
**I want to** see a hierarchical document structure with all symbols (functions, types, values) in the current file,
**so that** I can navigate quickly through code using the outline view, breadcrumb navigation, and understand the file structure at a glance.

## Acceptance Criteria
- [ ] Handle textDocument/documentSymbol requests
- [ ] Return hierarchical symbol structure
- [ ] Include all functions, types, and values
- [ ] Support symbol kinds appropriately
- [ ] Enable breadcrumb navigation
- [ ] Update dynamically with changes

## Tasks / Subtasks
- [ ] **Implement LSP document symbol handler** (AC: 1)
  - [ ] Add `document_symbol` method to `gren-lsp-protocol/src/handlers.rs`
  - [ ] Handle `DocumentSymbolParams` with proper document identification
  - [ ] Return `DocumentSymbol[]` (hierarchical) instead of deprecated `SymbolInformation[]`
  - [ ] Support capability registration in server initialization
  - [ ] Handle client capability negotiation for hierarchical symbols
- [ ] **Create document symbol extraction engine** (AC: 2, 3)
  - [ ] Create document symbol engine in `gren-lsp-core/src/document_symbols.rs`
  - [ ] Use tree-sitter AST to identify all symbol definitions in document
  - [ ] Extract function definitions with proper name and signature ranges
  - [ ] Extract type alias definitions with their full definition range
  - [ ] Extract union type definitions with constructor enumeration
  - [ ] Extract value definitions with type annotations when available
  - [ ] Extract module-level constants and configurations
  - [ ] Handle nested definitions within let-expressions
- [ ] **Map Gren symbols to LSP SymbolKind** (AC: 4)
  - [ ] Map Gren functions to `SymbolKind.Function` (12)
  - [ ] Map union types to `SymbolKind.Enum` (10) with constructors as `SymbolKind.EnumMember` (22)
  - [ ] Map type aliases to `SymbolKind.Interface` (11) for structural types
  - [ ] Map value bindings to `SymbolKind.Variable` (13) or `SymbolKind.Constant` (14)
  - [ ] Map module declarations to `SymbolKind.Module` (2)
  - [ ] Handle exposed/private symbol visibility appropriately
- [ ] **Build hierarchical symbol structure** (AC: 2)
  - [ ] Create parent-child relationships for nested definitions
  - [ ] Handle let-expressions as containers for local symbols
  - [ ] Organize case expressions with their pattern branches
  - [ ] Structure union type constructors under their parent type
  - [ ] Calculate proper range and selectionRange for each symbol
  - [ ] Ensure ranges are non-overlapping and properly nested
- [ ] **Enable editor navigation features** (AC: 5)
  - [ ] Generate meaningful symbol detail strings (type signatures, value types)
  - [ ] Provide accurate selectionRange for symbol name highlighting
  - [ ] Support outline view sorting and filtering by symbol kind
  - [ ] Enable breadcrumb navigation with proper symbol hierarchy
  - [ ] Support goto-symbol-in-file functionality
- [ ] **Implement dynamic symbol updates** (AC: 6)
  - [ ] Integrate with document change notifications for incremental updates
  - [ ] Invalidate and regenerate symbols when document content changes
  - [ ] Optimize for partial symbol extraction when changes are localized
  - [ ] Handle syntax errors gracefully without breaking symbol extraction
  - [ ] Cache symbol extraction results for unchanged document regions
- [ ] **Add comprehensive unit tests for document symbols** (AC: All)
  - [ ] Test document symbol request handling and response format compliance
  - [ ] Test symbol extraction accuracy for various Gren language constructs
  - [ ] Test hierarchical structure generation with nested definitions
  - [ ] Test SymbolKind mapping for different Gren symbol types
  - [ ] Test range and selectionRange calculation for symbol positioning
  - [ ] Test dynamic updates when document content changes
  - [ ] Test error handling with malformed or incomplete Gren code
  - [ ] Test performance with large files containing many symbols

## Dev Notes

### Previous Story Insights
Story 3.7 (Code Actions and Quick Fixes) established comprehensive tree-sitter AST analysis patterns and WorkspaceEdit generation that provide the foundation for precise symbol extraction. The tree-sitter parsing infrastructure enables accurate identification of all symbol definitions, while the existing LSP handler patterns provide templates for protocol method implementation.

### Data Models
**DocumentSymbol Model**: [Source: docs/lsp-spec/3.18/language/documentSymbol.md#documentSymbol]
- DocumentSymbol represents hierarchical programming constructs with name, kind, and ranges
- Must set `range` (full symbol definition) and `selectionRange` (symbol name only)
- Supports `detail` field for additional information like type signatures
- Enables hierarchical structure via `children` array for nested symbols
- Supports `tags` for marking deprecated symbols (using SymbolTag.Deprecated)

**SymbolKind Mapping**: [Source: docs/lsp-spec/3.18/language/documentSymbol.md#symbolKind]
- Function (12) - Gren function definitions
- Enum (10) - Gren union types
- EnumMember (22) - Gren union type constructors
- Interface (11) - Gren type aliases
- Variable (13) - Gren value bindings
- Constant (14) - Gren immutable values
- Module (2) - Gren module declarations

**Symbol Model**: [Source: docs/architecture/data-models.md#symbol-model]
- Enhanced for document symbols with hierarchical relationships
- `location` provides Range for symbol definition in document
- `kind` maps to appropriate LSP SymbolKind values
- `documentation` provides optional detail information for symbols

### API Specifications
**LSP Protocol Methods**: [Source: docs/lsp-spec/3.18/language/documentSymbol.md]
- `textDocument/documentSymbol` - Request document symbols, returns DocumentSymbol[] (hierarchical preferred)
- Server capabilities: documentSymbolProvider with optional label for UI display
- Client capability: hierarchicalDocumentSymbolSupport determines return format

**Tree-sitter Integration**: [Source: docs/architecture/external-apis.md#tree-sitter-grammar-integration]
- `ts_parser_parse()` provides semantic AST for comprehensive symbol extraction
- Tree-sitter queries enable identification of all Gren language constructs
- AST node traversal supports hierarchical symbol relationship building

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Existing handlers.rs structure provides template for document symbol method implementation
- JSON-RPC communication pattern established for handling DocumentSymbolParams
- Response formatting capabilities available for DocumentSymbol array generation

**Analysis Engine Integration**: [Source: docs/architecture/components.md#analysis-engine]
- Tree-sitter parsing provides accurate syntax tree for symbol identification
- Symbol indexing supports lookup operations for cross-referencing
- Document management enables incremental symbol updates

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main document symbol method implementation location
**Document Symbol Engine**: `/gren-lsp-core/src/document_symbols.rs` - New module for symbol extraction logic
**Testing**: `/gren-lsp-protocol/tests/document_symbol_tests.rs` - Integration tests for document symbols
**Unit Tests**: Individual `mod.rs` files with `#[cfg(test)]` modules alongside implementations

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` for symbol extraction logic validation
- Integration tests in `/tests/` directories for LSP protocol compliance
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace
- Performance testing with `criterion` for symbol extraction benchmarks

**Specific Test Cases Required**:
- Document symbol request parsing and response formatting compliance
- Symbol extraction accuracy for functions, types, values, and modules
- Hierarchical structure generation preserves proper parent-child relationships
- SymbolKind mapping correctly represents Gren language constructs
- Range and selectionRange calculation provides accurate symbol positioning
- Dynamic updates maintain symbol accuracy when document changes
- Error handling gracefully handles incomplete or malformed Gren code
- Performance remains responsive with large files containing many symbols

### Technical Constraints
**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **Pure functional benefits**: All functions are pure, making symbol analysis predictable and cacheable
- **Small Language Syntax Benefits**: Limited constructs mean comprehensive symbol coverage is feasible with tree-sitter
- **Array-First Data Model**: Efficient symbol storage aligns with Gren's performance characteristics
- **No-exception error model**: All error cases explicit in types, enabling complete symbol extraction even with partial parsing

**Error Handling Strategy**: [Source: docs/architecture/error-handling-strategy.md#graceful-degradation]
- **Critical requirement**: Document symbols must provide meaningful structure even with syntax errors
- Implement graceful degradation when AST analysis incomplete - return partial symbols rather than empty results
- Use structured error reporting for symbol extraction failures
- Provide fallback to basic symbol identification when advanced analysis unavailable

### Performance Considerations
**Symbol Extraction Optimization**: [Source: docs/architecture/performance-considerations.md]
- **Async Processing**: Non-blocking request handling for editor responsiveness during symbol extraction
- **Request Prioritization**: Document symbols as interactive navigation feature requires fast response
- **Incremental Updates**: Optimize symbol re-extraction for document changes by analyzing only modified regions  
- **Bounded Computation**: Cache symbol extraction results for unchanged document content

**Tree-sitter Performance**: [Source: docs/architecture/data-models.md#sourcefile-model]
- Tree-sitter incremental parsing minimizes reanalysis overhead for symbol updates
- AST node caching reduces traversal costs for repeated symbol extraction requests
- Document-scoped queries optimize performance for symbol identification

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/document_symbol_tests.rs`
- Performance tests: `gren-lsp-protocol/benches/document_symbol_bench.rs`
- Symbol extraction tests: `gren-lsp-core/src/document_symbols.rs` - `#[cfg(test)]` modules

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace and documents using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual Gren files
- Follow Rust testing conventions with descriptive test names
- Performance benchmarks using `criterion` crate

### Specific Testing Requirements:
- Test document symbol request handling and hierarchical DocumentSymbol response format
- Test symbol extraction completeness for all Gren language constructs (functions, types, values)
- Test hierarchical structure accuracy with nested definitions and proper parent-child relationships
- Test SymbolKind mapping correctness for Gren-specific language constructs
- Test range and selectionRange precision provides accurate symbol positioning for navigation
- Test dynamic symbol updates maintain accuracy and performance with document changes
- Test error resilience when processing incomplete or syntactically incorrect Gren code
- Test performance characteristics with large files containing extensive symbol definitions
- Test client capability negotiation for hierarchical vs flat symbol representation
- Test breadcrumb navigation integration with generated symbol hierarchy

## Project Structure Notes

The existing LSP handler implementation provides established patterns for protocol method implementation and JSON-RPC response formatting. The tree-sitter parsing infrastructure enables comprehensive AST analysis required for accurate symbol extraction across all Gren language constructs. The symbol indexing system provides context for cross-file symbol relationships, while the document management system supports incremental updates for dynamic symbol refresh.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 8 | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*