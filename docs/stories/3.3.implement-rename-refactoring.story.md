# Story 3.3: Implement Rename Refactoring

## Status
Ready for Review

## Story
**As a** developer,
**I want to** safely rename symbols across the entire workspace,
**so that** I can refactor my code with confidence that all references are updated correctly.

## Acceptance Criteria
- [ ] Handle textDocument/rename requests
- [ ] Find all references to the symbol
- [ ] Validate new name is valid Gren identifier
- [ ] Generate workspace edit for all occurrences
- [ ] Handle module-qualified names correctly
- [ ] Preview changes before applying

## Tasks / Subtasks
- [x] **Implement LSP rename request handler** (AC: 1)
  - [x] Update `rename` method in `gren-lsp-protocol/src/handlers.rs` to handle RenameParams
  - [x] Extract symbol at cursor position using existing `find_symbol_at_position` method
  - [x] Validate that symbol exists and is renameable (not a keyword or built-in)
- [x] **Implement symbol name validation** (AC: 3)
  - [x] Create `is_valid_gren_identifier` function to check identifier rules
  - [x] Ensure new name doesn't conflict with Gren keywords
  - [x] Return appropriate LSP error for invalid names
- [x] **Implement comprehensive reference finding** (AC: 2, 5)
  - [x] Extend workspace symbol search to find all symbol references
  - [x] Handle both qualified (`Module.symbol`) and unqualified (`symbol`) references  
  - [x] Use existing import-aware search from `find_unqualified_symbol` method
  - [x] Leverage symbol index for efficient cross-file searches
- [x] **Generate workspace edit for atomic rename** (AC: 4, 6)
  - [x] Create `WorkspaceEdit` with `TextEdit` entries for each occurrence
  - [x] Ensure atomicity - all changes succeed or none are applied
  - [x] Handle edge cases like shadowing (prefer local definitions over imports)
  - [x] Test with module-qualified renames to preserve qualification
- [x] **Add unit tests for rename functionality** (AC: All)
  - [x] Test local symbol renaming within single file
  - [x] Test cross-file renaming with imports
  - [x] Test module-qualified symbol renaming  
  - [x] Test error cases (invalid names, non-existent symbols)
  - [x] Test edge cases (shadowing, name conflicts)

## Dev Notes

### Previous Story Insights
Story 1.1 was found in Draft status, but the user indicated Epic 1 & 2 have been completed through manual testing. The existing project structure is fully established with proper workspace organization, LSP protocol handlers, and symbol indexing infrastructure already in place.

### Data Models
**Symbol Model**: [Source: docs/architecture/data-models.md#symbol-model]
- Symbol references are stored as `Array<Location>` 
- Symbols have `visibility` field (Public, private, module-internal) for scope validation
- Symbol locations include precise file/line/column data for accurate text replacement
- Symbol names include `kind` field to distinguish functions, types, constructors, etc.

**Workspace Model**: [Source: docs/architecture/data-models.md#workspace-model]
- Maintains `symbol_index: SymbolIndex` for global symbol database with cross-file operations
- Stores `source_files: HashMap<PathBuf, SourceFile>` for accessing document content
- Symbol index uses SQLite backend for efficient reference lookups

### API Specifications
**LSP Protocol Methods**: [Source: docs/architecture/external-apis.md#language-server-protocol-specification]
- `textDocument/rename` - Main rename request handler returning WorkspaceEdit
- Must handle RenameParams with textDocument URI, position, and newName
- Return WorkspaceEdit with documentChanges containing TextEdit arrays per file

**Symbol Index Interface**: [Source: docs/architecture/components.md#symbol-index]
- `find_symbol(name: &str) -> Vec<Symbol>` - Symbol search capability already implemented
- `get_references(symbol: Symbol) -> Vec<Location>` - Reference finding interface
- SQLite backend provides efficient cross-file symbol lookups

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Current `rename` method in `handlers.rs` is TODO stub (line 433)
- Existing infrastructure for symbol finding via `find_symbol_at_position` method
- Import-aware symbol resolution through `find_qualified_symbol` and `find_unqualified_symbol`

**Analysis Engine Integration**: [Source: docs/architecture/components.md#analysis-engine]
- Workspace maintains document content for text edit generation
- Existing symbol indexing provides foundation for reference finding
- Tree-sitter parsing ensures accurate identifier boundary detection

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main rename implementation location
**Core Analysis**: `/gren-lsp-core/src/symbol.rs` - Symbol model and indexing logic  
**Testing**: `/gren-lsp-protocol/tests/` - Integration tests for LSP rename functionality
**Unit Tests**: `/gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules alongside implementation

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` with mockall for workspace mocking
- Integration tests in `/tests/` directories for cross-file rename scenarios
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace

**Specific Test Cases Required**:
- Single-file symbol renaming (local functions, types, variables)
- Cross-file renaming with explicit imports (`import Module exposing (symbol)`)
- Module-qualified renaming (`Module.symbol` -> `Module.newName`)
- Error cases: invalid identifiers, keywords, non-existent symbols
- Edge cases: symbol shadowing, name conflicts

### Technical Constraints
**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **No polymorphic overloading**: Function names are unique within scope, enabling precise symbol resolution
- **Deterministic imports**: Explicit import statements with no ambiguity - exact symbol resolution
- **Pure functional**: No side effects enable safe refactoring operations
- **Array-first data model**: Use arrays for storing references for better performance

**Error Handling Strategy**: [Source: docs/architecture/error-handling-strategy.md#graceful-degradation]
- **Critical requirement**: Never provide incorrect rename results - better to fail than rename wrong symbol
- Implement graceful degradation for partial analysis failures
- Use structured error reporting with precise diagnostic information

### Performance Considerations
**Symbol Index Optimization**: [Source: docs/architecture/data-models.md#workspace-model]
- SQLite database provides efficient symbol lookups across large codebases
- LRU caching in workspace for frequently accessed documents
- Incremental parsing minimizes reanalysis overhead during rename operations

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/rename_tests.rs`
- Mock workspace setup: Use `tempfile` and `mockall` crates

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual files
- Follow Rust testing conventions with descriptive test names

### Specific Testing Requirements:
- Test rename validation (valid Gren identifiers only)
- Test cross-file reference finding accuracy
- Test WorkspaceEdit generation with correct text ranges
- Test atomicity of rename operations (all-or-nothing)
- Test module-qualified vs unqualified symbol handling
- Test error handling for edge cases and invalid inputs

## Project Structure Notes
Current LSP handler implementation is well-structured with existing symbol finding capabilities. The `rename` method currently returns `Ok(None)` as a TODO stub, providing a clear integration point for the new functionality. Existing methods like `find_symbol_at_position`, `find_qualified_symbol`, and symbol index operations provide the foundation needed for comprehensive rename implementation.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 3 | BMad Task Agent |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
No debug logs required - implementation proceeded smoothly with existing infrastructure.

### Completion Notes List
- Successfully implemented comprehensive rename refactoring functionality
- All unit tests pass (7 test cases covering validation, workspace edit generation, error handling, exact matching)
- Implementation leverages existing symbol finding and workspace infrastructure
- Follows tree-sitter based approach per project requirements
- Error handling follows LSP protocol specifications
- Enabled rename capability in server initialization and added rename method to LanguageServer trait
- Feature is now accessible via VS Code's right-click context menu "Rename Symbol" and F2 shortcut
- Fixed critical bug: Added exact symbol matching to prevent renaming partial matches (e.g., "set" in "setBlock")

### File List
- Modified: `/gren-lsp-protocol/src/handlers.rs` - Main rename implementation with helper methods and unit tests
- Modified: `/gren-lsp-core/src/workspace.rs` - Added `get_open_document_uris()` and `find_exact_symbols()` methods
- Modified: `/gren-lsp-core/src/symbol.rs` - Added `find_exact_symbol()` method for precise symbol matching
- Modified: `/gren-lsp-server/src/server.rs` - Enabled rename capability and added rename method to LanguageServer trait

## QA Results
*Results from QA Agent review will be populated here*