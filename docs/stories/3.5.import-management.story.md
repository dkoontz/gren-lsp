# Story 3.5: Import Management

## Status
Ready

## Story
**As a** developer,
**I want to** have intelligent import suggestions and automatic import organization,
**so that** I can efficiently manage module dependencies and maintain clean, organized import statements.

## Acceptance Criteria
- [ ] Suggest imports for unresolved symbols
- [ ] Generate import statements automatically
- [ ] Remove unused imports on request
- [ ] Organize imports alphabetically
- [ ] Handle exposing lists correctly
- [ ] Support quick fix code actions

## Tasks / Subtasks
- [ ] **Implement unresolved symbol detection** (AC: 1)
  - [ ] Update textDocument/publishDiagnostics to identify unresolved symbols using tree-sitter
  - [ ] Query Symbol Index to find available symbols matching unresolved names
  - [ ] Generate diagnostic with code action for import suggestions
  - [ ] Handle both qualified (`Module.symbol`) and unqualified (`symbol`) symbol resolution
- [ ] **Implement LSP code action handler for import suggestions** (AC: 1, 6)
  - [ ] Update `code_action` method in `gren-lsp-protocol/src/handlers.rs` to handle import-related actions
  - [ ] Generate textDocument/codeAction responses with import suggestions for unresolved symbols
  - [ ] Provide "Add import" quick fixes with multiple import options when symbol exists in multiple modules
  - [ ] Support workspace edit generation to add import statements at correct location
- [ ] **Implement automatic import statement generation** (AC: 2)
  - [ ] Create import statement formatter following Gren syntax: `import ModuleName exposing (symbol)`
  - [ ] Detect existing import block location using tree-sitter AST parsing
  - [ ] Insert new imports at appropriate location (after module declaration, before function definitions)
  - [ ] Handle both qualified imports (`import Module`) and exposing imports (`import Module exposing (symbol)`)
  - [ ] Update existing imports by adding to exposing list when module already imported
- [ ] **Implement unused import detection and removal** (AC: 3)
  - [ ] Analyze workspace to identify imports that are not referenced in the file
  - [ ] Use Symbol Index to cross-reference imported symbols with actual usage
  - [ ] Generate code actions for removing unused imports individually or in bulk
  - [ ] Handle exposing list cleanup (remove unused symbols from exposing lists)
  - [ ] Preserve imports that are used in qualified form (`Module.symbol`)
- [ ] **Implement import organization and alphabetization** (AC: 4)
  - [ ] Create code action to sort imports alphabetically by module name
  - [ ] Group imports by type (core libraries, third-party packages, local modules)
  - [ ] Sort exposing lists alphabetically within each import statement
  - [ ] Maintain consistent import formatting following Gren conventions
  - [ ] Handle edge cases like multiline exposing lists and comments
- [ ] **Handle exposing lists correctly** (AC: 5)
  - [ ] Parse and validate exposing list syntax using tree-sitter
  - [ ] Support adding symbols to existing exposing lists without duplicates
  - [ ] Handle exposing everything (`exposing (..)`) vs explicit symbol lists
  - [ ] Manage exposing list formatting and line length considerations
  - [ ] Update exposing lists when symbols are renamed or removed
- [ ] **Add comprehensive unit tests for import management** (AC: All)
  - [ ] Test unresolved symbol detection across different contexts (functions, types, values)
  - [ ] Test import suggestion generation with multiple module options
  - [ ] Test automatic import insertion at correct file locations
  - [ ] Test unused import detection and removal accuracy
  - [ ] Test import organization and alphabetical sorting
  - [ ] Test exposing list manipulation and formatting
  - [ ] Test edge cases: malformed imports, circular dependencies, shadowing
  - [ ] Test performance with large workspaces and many imports

## Dev Notes

### Previous Story Insights
Story 3.4 (Find All References) established comprehensive workspace symbol search capabilities through the Symbol Index and cross-file reference tracking. The existing infrastructure for symbol resolution, qualified/unqualified name handling, and tree-sitter-based AST analysis provides the foundation for import management functionality.

### Data Models
**Symbol Model**: [Source: docs/architecture/data-models.md#symbol-model]
- Symbol references are stored as `Array<Location>` using Gren's array-first approach for efficient lookup
- Symbols have `visibility` field (Public, private, module-internal) for determining import availability
- Symbol locations include precise file/line/column data for import statement generation
- Symbol names include `kind` field to distinguish functions, types, constructors for import categorization
- `references: Array<Location>` field enables unused import detection by checking actual usage

**Workspace Model**: [Source: docs/architecture/data-models.md#workspace-model]  
- Maintains `symbol_index: SymbolIndex` for global symbol database enabling cross-module import resolution
- Stores `source_files: HashMap<PathBuf, SourceFile>` for analyzing import statements and usage patterns
- Symbol index uses SQLite backend for efficient symbol lookup across all workspace modules

### API Specifications
**LSP Protocol Methods**: [Source: docs/architecture/external-apis.md#language-server-protocol-specification]
- `textDocument/codeAction` - Main handler for import-related quick fixes and organization actions
- `textDocument/publishDiagnostics` - Report unresolved symbols as diagnostics with import suggestions
- Code actions must return WorkspaceEdit with TextEdit operations for import modifications
- Support CodeActionKind.QuickFix for import suggestions and CodeActionKind.Source for organization

**Symbol Index Interface**: [Source: docs/architecture/components.md#symbol-index]
- `find_symbol(name: &str) -> Vec<Symbol>` - Locate symbols for import suggestion matching
- Existing symbol search capability provides foundation for resolving unresolved symbol references
- SQLite backend enables efficient lookup of available symbols across all workspace modules

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Current handlers in `handlers.rs` provide foundation for code action implementation
- Existing diagnostic publishing infrastructure can be extended for unresolved symbol reporting
- Import statement manipulation requires workspace edit generation and text modification capabilities

**Analysis Engine Integration**: [Source: docs/architecture/components.md#analysis-engine]
- Tree-sitter parsing provides accurate import statement AST for manipulation and organization
- Existing symbol indexing enables cross-file import resolution and usage tracking
- Workspace document management supports import statement modification and formatting

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main import management implementation location
**Core Analysis**: `/gren-lsp-core/src/symbol.rs` - Symbol resolution logic for import suggestion matching
**Testing**: `/gren-lsp-protocol/tests/` - Integration tests for import management functionality
**Unit Tests**: `/gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules alongside implementation

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` with mockall for workspace mocking
- Integration tests in `/tests/` directories for cross-file import scenarios
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace
- Performance testing with `criterion` for large workspace import operations

**Specific Test Cases Required**:
- Unresolved symbol detection in various contexts (function calls, type annotations, patterns)
- Import suggestion generation with multiple module options and user selection
- Automatic import insertion maintaining proper file structure and formatting
- Unused import detection accuracy with qualified vs exposing imports
- Import organization with alphabetical sorting and grouping
- Exposing list manipulation without breaking existing imports
- Performance benchmarks for import operations in large codebases

### Technical Constraints
**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **Deterministic imports**: Explicit import statements with no ambiguity enable precise import management
- **No polymorphic overloading**: Function names are unique within scope, simplifying import suggestion logic
- **Pure functional**: No side effects enable safe import manipulation without runtime concerns
- **Array-first data model**: Use arrays for storing import suggestions for better performance

**Error Handling Strategy**: [Source: docs/architecture/error-handling-strategy.md#graceful-degradation]
- **Critical requirement**: Import suggestions must be accurate - better to show fewer options than incorrect imports
- Implement graceful degradation for partial analysis failures (some modules may be unparseable)
- Use structured error reporting for import manipulation failures with rollback capability

### Performance Considerations
**Symbol Index Optimization**: [Source: docs/architecture/performance-considerations.md]
- **LRU Caching**: Bounded memory usage for frequently accessed symbol lookups and import suggestions
- **Incremental Analysis**: Only re-index changed files to maintain import suggestion accuracy
- **Async Processing**: Non-blocking request handling for editor responsiveness during import operations
- **Request Prioritization**: Import suggestions prioritized as interactive operations requiring fast response

**Import Processing Optimization**: [Source: docs/architecture/data-models.md#workspace-model]
- SQLite database provides efficient symbol lookups for cross-module import resolution
- Array-based symbol storage aligns with Gren's performance characteristics for suggestion lists
- Tree-sitter incremental parsing minimizes reanalysis overhead during import modifications

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/import_management_tests.rs`
- Performance tests: `gren-lsp-protocol/benches/imports_bench.rs`
- Mock workspace setup: Use `tempfile` and `mockall` crates

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual Gren files
- Follow Rust testing conventions with descriptive test names
- Performance benchmarks using `criterion` crate

### Specific Testing Requirements:
- Test import suggestion accuracy across different symbol types and contexts
- Test automatic import insertion maintains proper Gren file structure
- Test unused import detection with complex import patterns
- Test import organization preserves semantic correctness
- Test exposing list manipulation edge cases and formatting
- Test performance with large workspaces (>1000 files, >10000 symbols)
- Test error handling for malformed import statements and circular dependencies
- Test incremental updates when imports change

## Project Structure Notes
The existing LSP handler implementation provides a solid foundation with symbol indexing and tree-sitter parsing capabilities. The import management functionality can leverage the existing Symbol Index for cross-module symbol resolution, AST manipulation for import statement editing, and diagnostic publishing for unresolved symbol reporting. The `find_symbol` and reference tracking capabilities established in previous stories provide the core infrastructure needed for comprehensive import management.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 5 | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*