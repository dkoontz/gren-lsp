# Story 3.7: Code Actions and Quick Fixes

## Status
Ready

## Story
**As a** developer,
**I want to** receive contextual code actions for common tasks and error fixes,
**so that** I can quickly address type errors, extract functions, add missing annotations, and perform other common refactoring operations.

## Acceptance Criteria
- [ ] Handle textDocument/codeAction requests
- [ ] Suggest fixes for common type errors
- [ ] Add missing type annotations
- [ ] Convert between related types
- [ ] Extract expressions to functions
- [ ] Generate case expressions for custom types

## Tasks / Subtasks
- [ ] **Implement LSP code action handler** (AC: 1)
  - [ ] Add `code_action` method to `gren-lsp-protocol/src/handlers.rs`
  - [ ] Handle `CodeActionParams` with proper context parsing
  - [ ] Return `CodeAction[]` or `Command[]` array for available actions
  - [ ] Support capability registration in server initialization
  - [ ] Handle code action filtering by `CodeActionKind` (quickfix, refactor, source)
- [ ] **Implement quickfix code actions** (AC: 2)
  - [ ] Create quickfix engine in `gren-lsp-core/src/code_actions/quickfix.rs`
  - [ ] Analyze diagnostics in CodeActionContext to suggest fixes
  - [ ] Generate fixes for common type mismatch errors
  - [ ] Create fixes for undefined variable errors with import suggestions
  - [ ] Handle missing case pattern fixes for union types
  - [ ] Generate WorkspaceEdit for each quickfix action
- [ ] **Add missing type annotation actions** (AC: 3)
  - [ ] Create type annotation engine in `gren-lsp-core/src/code_actions/type_annotations.rs`
  - [ ] Detect functions and values without explicit type annotations
  - [ ] Use tree-sitter AST to identify annotation locations
  - [ ] Generate type annotations from inferred types (when available)
  - [ ] Create TextEdit operations to insert type annotations
  - [ ] Support both top-level and let-bound function annotations
- [ ] **Implement type conversion actions** (AC: 4)
  - [ ] Create type conversion engine in `gren-lsp-core/src/code_actions/type_conversions.rs`
  - [ ] Detect Maybe/Result conversion opportunities
  - [ ] Suggest Array ↔ String conversions
  - [ ] Handle numeric type conversions (Int ↔ Float)
  - [ ] Generate appropriate wrapper/unwrapping code
  - [ ] Validate conversion safety and semantic preservation
- [ ] **Implement extract function refactoring** (AC: 5)
  - [ ] Create extraction engine in `gren-lsp-core/src/code_actions/extract.rs`
  - [ ] Detect extractable expressions based on selection range
  - [ ] Analyze variable dependencies and capture requirements
  - [ ] Generate new function definition with appropriate parameters
  - [ ] Create function call to replace extracted expression
  - [ ] Handle scope analysis for proper parameter identification
  - [ ] Generate meaningful function names based on expression content
- [ ] **Generate case expression actions** (AC: 6)
  - [ ] Create case generation engine in `gren-lsp-core/src/code_actions/case_generation.rs`
  - [ ] Detect custom type usage that could benefit from case expressions
  - [ ] Generate complete case expressions with all constructor patterns
  - [ ] Handle nested pattern matching for complex types
  - [ ] Insert appropriate placeholder expressions for each case
  - [ ] Support both exhaustive and partial case generation
- [ ] **Add comprehensive unit tests for code actions** (AC: All)
  - [ ] Test code action request handling and response formatting
  - [ ] Test quickfix generation for various diagnostic types
  - [ ] Test type annotation insertion for different function patterns
  - [ ] Test type conversion suggestions and generated code
  - [ ] Test extract function with various expression types and scopes
  - [ ] Test case expression generation for different custom types
  - [ ] Test code action filtering by kind and context
  - [ ] Test WorkspaceEdit application and validation

## Dev Notes

### Previous Story Insights
Story 3.6 (Code Formatting Integration) established comprehensive TextEdit generation patterns and WorkspaceEdit management that provide the foundation for code action implementations. The tree-sitter parsing infrastructure enables precise AST analysis needed for code action suggestions, while the existing diagnostic reporting system provides the context for quickfix actions.

### Data Models
**CodeAction Model**: [Source: docs/lsp-spec/3.18/language/codeAction.md#codeAction]
- CodeAction represents executable changes with title, kind, and optional WorkspaceEdit
- Must set either `edit` (WorkspaceEdit) or `command` (Command) to specify the action
- Supports categorization via CodeActionKind (quickfix, refactor.extract, source)
- Can reference diagnostics that the action resolves
- Supports isPreferred flag for default actions and disabled state with reason

**CodeActionKind Categories**: [Source: docs/lsp-spec/3.18/language/codeAction.md#codeActionKind]
- `quickfix` - Fix problems and errors (type errors, missing imports)
- `refactor.extract` - Extract functions, variables, or expressions
- `refactor.rewrite` - Convert code structures and types
- `source` - File-wide operations (organize imports, fix all)

**CodeActionContext Model**: [Source: docs/lsp-spec/3.18/language/codeAction.md#codeActionContext]
- Contains diagnostics overlapping the requested range for quickfix context
- Includes `only` field to filter by specific CodeActionKind values
- Provides triggerKind (Invoked=1, Automatic=2) for behavior optimization

### API Specifications
**LSP Protocol Methods**: [Source: docs/lsp-spec/3.18/language/codeAction.md]
- `textDocument/codeAction` - Request code actions for document range, returns CodeAction[] or Command[]
- `codeAction/resolve` - Optional lazy resolution for expensive edit computation
- Server capabilities: codeActionProvider with optional resolveProvider and codeActionKinds

**Tree-sitter Integration**: [Source: docs/architecture/external-apis.md#tree-sitter-grammar-integration]
- `ts_parser_parse()` provides semantic AST for accurate code action analysis
- Tree-sitter queries enable identification of extraction candidates and type patterns
- AST node traversal supports scope analysis for variable capture in extract operations

### Component Specifications
**LSP Protocol Handler**: [Source: docs/architecture/components.md#lsp-protocol-handler]
- Existing handlers.rs structure provides template for code action method implementation
- JSON-RPC communication pattern established for handling CodeActionParams
- WorkspaceEdit generation capabilities available from formatting implementation

**Analysis Engine Integration**: [Source: docs/architecture/components.md#analysis-engine]
- Tree-sitter parsing provides accurate syntax tree for code action detection
- Diagnostic information available for quickfix action context
- Symbol resolution supports type inference for annotation generation

### File Locations
**Protocol Handlers**: `/gren-lsp-protocol/src/handlers.rs` - Main code action implementation location
**Code Action Engines**: `/gren-lsp-core/src/code_actions/` - Directory for specialized action engines:
  - `quickfix.rs` - Diagnostic-based quick fixes
  - `type_annotations.rs` - Type annotation insertion
  - `type_conversions.rs` - Type conversion suggestions
  - `extract.rs` - Extract function refactoring
  - `case_generation.rs` - Case expression generation
**Testing**: `/gren-lsp-protocol/tests/code_action_tests.rs` - Integration tests for code actions
**Unit Tests**: Individual `mod.rs` files with `#[cfg(test)]` modules alongside implementations

### Testing Requirements
**Testing Strategy**: [Source: docs/architecture/tech-stack.md#technology-stack-table]
- Unit tests using `cargo test` for code action logic validation
- Integration tests in `/tests/` directories for LSP protocol compliance
- Test frameworks: `cargo test`, `criterion`, `mockall` already configured in workspace
- Performance testing with `criterion` for action generation benchmarks

**Specific Test Cases Required**:
- Code action request parsing and response formatting compliance
- Quickfix generation accuracy for various Gren diagnostic types
- Type annotation insertion preserves semantic correctness
- Type conversion suggestions maintain type safety
- Extract function handles variable capture and scoping correctly
- Case expression generation covers all constructor variants
- Code action filtering by kind works with client preferences
- WorkspaceEdit validation ensures syntactically correct results

### Technical Constraints

**⚠️ CRITICAL: Tree-sitter AST Requirement**: [Source: docs/architecture/tree-sitter-ast-structure.md]
- **MANDATORY**: All code action analysis MUST use tree-sitter AST for understanding code structure
- **NEVER**: Use text-based parsing (regex, string matching) for code action detection or generation
- **Tree-sitter Queries**: Use proper node analysis: `(value_declaration)`, `(type_annotation)`, `(case_expr)`, etc.
- **Context Analysis**: Use AST-based detection for function boundaries, type contexts, and expression scopes
- **Reference**: See comprehensive AST structure guide and examples in tree-sitter architecture document

**Gren Language Characteristics**: [Source: docs/architecture/gren-specific-lsp-considerations.md]
- **Pure functional benefits**: All functions are pure, making code action analysis predictable and cacheable
- **Small Language Syntax Benefits**: Limited constructs mean comprehensive code action coverage is feasible
- **Effect transparency**: Cmd types visible in signatures enable accurate action suggestions for side effects
- **No-exception error model**: All error cases explicit in types, enabling complete quickfix coverage

**Error Handling Strategy**: [Source: docs/architecture/error-handling-strategy.md#graceful-degradation]
- **Critical requirement**: Code actions must generate syntactically valid Gren code
- Implement graceful degradation when AST analysis incomplete - return fewer actions rather than invalid ones
- Use structured error reporting for action generation failures
- Provide fallback to basic actions when advanced analysis unavailable

### Performance Considerations
**Code Action Optimization**: [Source: docs/architecture/performance-considerations.md]
- **Async Processing**: Non-blocking request handling for editor responsiveness during action computation
- **Request Prioritization**: Interactive code actions prioritized as user-triggered operations
- **Lazy Resolution**: Use codeAction/resolve for expensive edit computation when supported by client
- **Bounded Computation**: Limit analysis scope to requested range for performance

**Tree-sitter Performance**: [Source: docs/architecture/data-models.md#sourcefile-model]
- Tree-sitter incremental parsing minimizes reanalysis overhead for action detection
- AST node caching reduces traversal costs for repeated action requests
- Range-based queries optimize performance for targeted code action analysis

## Testing
### Test File Locations:
- Unit tests: `gren-lsp-protocol/src/handlers.rs` - `#[cfg(test)]` modules
- Integration tests: `gren-lsp-protocol/tests/code_action_tests.rs`
- Performance tests: `gren-lsp-protocol/benches/code_action_bench.rs`
- Code action engine tests: `gren-lsp-core/src/code_actions/` - `#[cfg(test)]` modules in each file

### Testing Standards:
- Use `cargo test` for unit test execution
- Mock workspace and diagnostics using `mockall` for isolated testing
- Use `tempfile` for temporary test workspaces with actual Gren files
- Follow Rust testing conventions with descriptive test names
- Performance benchmarks using `criterion` crate

### Specific Testing Requirements:
- Test code action discovery and filtering across all supported kinds
- Test quickfix accuracy for type errors, missing imports, and pattern matching
- Test type annotation generation for various function and value declarations  
- Test type conversion suggestions maintain semantic correctness
- Test extract function with complex expressions, nested scopes, and variable capture
- Test case expression generation for union types with multiple constructors
- Test WorkspaceEdit application produces valid, compilable Gren code
- Test performance with large files and complex AST analysis
- Test client capability negotiation and feature availability
- Test code action resolution for lazy edit computation

## Project Structure Notes

The existing LSP handler implementation provides a solid foundation with established patterns for protocol method implementation and WorkspaceEdit generation. The tree-sitter parsing infrastructure enables precise AST analysis required for intelligent code action suggestions. The diagnostic reporting system provides context for quickfix actions, while the symbol indexing supports scope analysis needed for extract function operations.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-07-30 | 1.0 | Initial story creation for Epic 3, Story 7 | BMad Task Agent |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References  
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be populated here*