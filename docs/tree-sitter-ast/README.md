# Tree-sitter AST Documentation for Gren

## Overview

This document provides comprehensive documentation of the tree-sitter AST (Abstract Syntax Tree) structure for Gren language constructs. The baseline AST was generated using the [tree-sitter-gren](https://github.com/MaeBrooks/tree-sitter-gren) grammar against our comprehensive reference file.

## Files

- `TreeSitterReference.gren` - Comprehensive Gren source file exercising all language constructs
- `baseline.ast` - Complete AST structure generated by `tree-sitter parse`

## Core Node Types

### Module Structure

#### `module_declaration`
Represents module declarations with exposing clauses.
- Fields: `name` (upper_case_qid), `exposing` (exposing_list)
- Example: `module TreeSitterReference exposing (..)`

#### `import_clause`
Represents import statements with optional as-clause and exposing.
- Fields: `moduleName` (upper_case_qid), `asClause` (as_clause), `exposing` (exposing_list)
- Examples:
  - `import Array exposing (..)`
  - `import Dict exposing (Dict)`
  - `import Platform.Cmd as Cmd`

### Type Definitions

#### `type_declaration`
Custom type definitions with union variants.
- Fields: `name` (upper_case_identifier), `unionVariant` (union_variant)
- Node pattern: `(type_declaration name: (upper_case_identifier) unionVariant: (union_variant...))`

#### `type_alias_declaration`
Type alias definitions.
- Fields: `name` (upper_case_identifier), `typeExpression` (type_expression)
- Node pattern: `(type_alias_declaration name: (upper_case_identifier) typeExpression: (type_expression...))`

#### `union_variant`
Individual variants in custom types.
- Fields: `name` (upper_case_identifier), optional `part` (type expressions)
- Examples: `Just Int`, `Nothing`, `Loading { progress : Float }`

### Function Definitions

#### `value_declaration`
Top-level function and value definitions.
- Fields: `functionDeclarationLeft` (function_declaration_left), `body` (expression)
- Pattern: `(value_declaration functionDeclarationLeft: (...) body: (...))`

#### `function_declaration_left`
Function name and parameter patterns.
- Fields: function name (lower_case_identifier), `pattern` nodes for parameters
- Examples: `add x y`, `processUser user`

#### `type_annotation`
Type signatures for functions and values.
- Fields: `name` (lower_case_identifier), `typeExpression` (type_expression)  
- Pattern: `(type_annotation name: (lower_case_identifier) typeExpression: (...))`

### Expressions

#### `let_in_expr`
Let expressions with local bindings.
- Fields: `valueDeclaration` nodes, `body` expression
- Pattern: `(let_in_expr valueDeclaration: (...) body: (...))`

#### `when_expr`
Pattern matching expressions (Gren's equivalent to case).
- Fields: `expr` (expression to match), `branch` nodes for patterns
- Pattern: `(when_expr expr: (...) branch: (...))`

#### `when_branch`
Individual branches in when expressions.
- Fields: `pattern` (pattern), `expr` (result expression)
- Pattern: `(when_branch pattern: (...) expr: (...))`

#### `function_call_expr` 
Function application expressions.
- Fields: `target` (function), `arg` (argument expressions)
- Pattern: `(function_call_expr target: (...) arg: (...))`

#### `record_expr`
Record creation and updates.
- Fields: `field` nodes for record fields
- Examples: `{ name = "test", age = 25 }`, `{ user | active = True }`

#### `array_expr`
Array literals.
- Fields: array elements as expression nodes
- Pattern: `(array_expr (value_expr...) (...))`

### Patterns

#### `lower_pattern`
Variable binding patterns.
- Fields: `lower_case_identifier`
- Used in function parameters, let bindings, pattern matching

#### `union_pattern`
Constructor patterns for pattern matching.
- Fields: `constructor` (upper_case_qid), `argPattern` for constructor arguments
- Examples: `Just value`, `Err message`

#### `record_pattern`
Record destructuring patterns.  
- Fields: `lower_pattern` nodes for field bindings
- Example: `{ name, age }`

#### `as_pattern`
Pattern aliasing with `as` keyword.
- Fields: `pattern` (inner pattern), alias name
- Example: `(User name age) as user`

### Literals and Identifiers

#### `value_expr`
Variable references and qualified names.
- Fields: `name` (value_qid)
- Examples: `x`, `Array.map`, `String.length`

#### `string_constant_expr`
String literals.
- Fields: `open_quote`, string content parts, `close_quote`
- Handles both regular strings and multi-line strings

#### `number_constant_expr`  
Numeric literals (integers, floats, hex).
- Examples: `42`, `3.14`, `0xFF`

#### `char_constant_expr`
Character literals.
- Examples: `'a'`, `'\n'`, `'\''`

### Operators and Function Composition

#### `bin_op_expr`
Binary operator expressions.
- Fields: `part` nodes for operands and operators
- Examples: `x + y`, `list |> Array.map String.length`

#### `operator`
Operator symbols.
- Fields: `operator_identifier`
- Examples: `+`, `++`, `|>`, `<|`, `==`

## Query Patterns for Symbol Extraction

### Function Definitions
```scheme
;; Function definitions with type annotations
(type_annotation
  name: (lower_case_identifier) @function.name
  typeExpression: (type_expression) @function.type)

(value_declaration
  functionDeclarationLeft: (function_declaration_left
    (lower_case_identifier) @function.name
    pattern: (lower_pattern)* @function.params)
  body: (_) @function.body)
```

### Import Statements
```scheme
;; Import statements with module names and exposed symbols
(import_clause
  moduleName: (upper_case_qid) @import.module
  exposing: (exposing_list
    (exposed_type 
      (upper_case_identifier) @import.exposed_type)
    (lower_case_identifier) @import.exposed_function))

(import_clause
  moduleName: (upper_case_qid) @import.module
  asClause: (as_clause
    name: (upper_case_identifier) @import.alias))
```

### Type Definitions  
```scheme
;; Custom type definitions
(type_declaration
  name: (upper_case_identifier) @type.name
  unionVariant: (union_variant
    name: (upper_case_identifier) @type.constructor)*)

;; Type aliases
(type_alias_declaration
  name: (upper_case_identifier) @type.name
  typeExpression: (type_expression) @type.definition)
```

### Symbol References
```scheme
;; Variable and function references  
(value_expr
  name: (value_qid
    (lower_case_identifier) @reference.name))

(value_expr  
  name: (value_qid
    (upper_case_identifier) @reference.module
    (lower_case_identifier) @reference.name))
```

### Pattern Matching Constructs
```scheme
;; When expression patterns
(when_expr
  expr: (_) @when.expression
  branch: (when_branch
    pattern: (_) @when.pattern
    expr: (_) @when.result)*)

;; Constructor patterns
(union_pattern
  constructor: (upper_case_qid
    (upper_case_identifier) @pattern.constructor)
  argPattern: (_)* @pattern.args)
```

## Error Handling

The tree-sitter parser includes error recovery mechanisms:
- `ERROR` nodes are generated for unparseable syntax
- Partial parsing continues after errors
- Error nodes contain the problematic source text
- Error recovery enables LSP functionality even with syntax errors

## Implementation Notes

### Position Tracking
- All nodes include byte ranges: `[start_line, start_char] - [end_line, end_char]`
- Zero-indexed line and column positions
- Enables precise symbol location for LSP operations

### Performance Considerations
- Tree-sitter provides incremental parsing
- Only modified sections are re-parsed on document changes
- Parse trees can be reused across LSP requests

### Symbol Resolution Strategy
1. **Local Scope**: Function parameters, let bindings
2. **Module Scope**: Top-level definitions in current module  
3. **Imported Scope**: Symbols from import statements
4. **Qualified Access**: Module.symbol references

### Query Performance
- Use specific node types in queries rather than wildcards
- Combine multiple patterns in single queries when possible
- Cache query results for frequently accessed symbols
- Index symbol locations for fast lookup

## Testing the AST

To validate AST generation:
1. Parse the reference file: `tree-sitter parse TreeSitterReference.gren`
2. Verify no parsing errors (ERROR nodes should be minimal)
3. Check that all language constructs are represented
4. Test queries extract expected symbols

## Next Steps

This AST documentation enables implementation of:
1. Symbol indexing and cross-module resolution
2. Go-to-definition functionality  
3. Hover information extraction
4. Code completion based on scope analysis
5. Rename refactoring operations
6. Find references across the workspace